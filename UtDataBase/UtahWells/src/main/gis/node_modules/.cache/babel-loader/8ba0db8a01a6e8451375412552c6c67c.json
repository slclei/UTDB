{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.23/esri/copyright.txt for details.\n*/\nimport { ViewingMode as e } from \"../../../../../ViewingMode.js\";\nimport { ScreenSizePerspective as r } from \"../util/ScreenSizePerspective.glsl.js\";\nimport { glsl as t } from \"../../shaderModules/interfaces.js\";\n\nfunction l(l, c) {\n  const i = l.vertex.code;\n  c.verticalOffsetEnabled ? (l.vertex.uniforms.add(\"verticalOffset\", \"vec4\"), c.screenSizePerspectiveEnabled && (l.include(r), l.vertex.uniforms.add(\"screenSizePerspectiveAlignment\", \"vec4\")), i.add(t`\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n      ${c.viewingMode === e.Global ? t`vec3 worldNormal = normalize(worldPos + localOrigin);` : t`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}\n      ${c.screenSizePerspectiveEnabled ? t`\n          float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));\n          float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);` : t`\n          float verticalOffsetScreenHeight = verticalOffset.x;`}\n      // Screen sized offset in world space, used for example for line callouts\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n\n    vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      return worldPos + calculateVerticalOffset(worldPos, localOrigin);\n    }\n    `)) : i.add(t`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`);\n}\n\nfunction c(e, r, t) {\n  if (!r.verticalOffset) return;\n  const l = i(r.verticalOffset, t.camera.fovY, t.camera.fullViewport[3]),\n        c = t.camera.pixelRatio || 1;\n  e.setUniform4f(\"verticalOffset\", l.screenLength * c, l.perDistance, l.minWorldLength, l.maxWorldLength);\n}\n\nfunction i(e, r, t) {\n  let l = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : o;\n  return l.screenLength = e.screenLength, l.perDistance = Math.tan(.5 * r) / (.5 * t), l.minWorldLength = e.minWorldLength, l.maxWorldLength = e.maxWorldLength, l;\n}\n\nconst o = {\n  screenLength: 0,\n  perDistance: 0,\n  minWorldLength: 0,\n  maxWorldLength: 0\n};\nexport { l as VerticalOffset, c as bindVerticalOffsetUniforms, i as calculateVerticalOffsetFactors };","map":{"version":3,"sources":["D:/Github/CUSP_DataBase/CUSP_DB/src/main/gis/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js"],"names":["ViewingMode","e","ScreenSizePerspective","r","glsl","t","l","c","i","vertex","code","verticalOffsetEnabled","uniforms","add","screenSizePerspectiveEnabled","include","viewingMode","Global","verticalOffset","camera","fovY","fullViewport","pixelRatio","setUniform4f","screenLength","perDistance","minWorldLength","maxWorldLength","o","Math","tan","VerticalOffset","bindVerticalOffsetUniforms","calculateVerticalOffsetFactors"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,WAAW,IAAIC,CAAtB,QAA4B,+BAA5B;AAA4D,SAAOC,qBAAqB,IAAIC,CAAhC,QAAsC,uCAAtC;AAA8E,SAAOC,IAAI,IAAIC,CAAf,QAAqB,mCAArB;;AAAyD,SAASC,CAAT,CAAWA,CAAX,EAAaC,CAAb,EAAe;AAAC,QAAMC,CAAC,GAACF,CAAC,CAACG,MAAF,CAASC,IAAjB;AAAsBH,EAAAA,CAAC,CAACI,qBAAF,IAAyBL,CAAC,CAACG,MAAF,CAASG,QAAT,CAAkBC,GAAlB,CAAsB,gBAAtB,EAAuC,MAAvC,GAA+CN,CAAC,CAACO,4BAAF,KAAiCR,CAAC,CAACS,OAAF,CAAUZ,CAAV,GAAaG,CAAC,CAACG,MAAF,CAASG,QAAT,CAAkBC,GAAlB,CAAsB,gCAAtB,EAAuD,MAAvD,CAA9C,CAA/C,EAA6JL,CAAC,CAACK,GAAF,CAAMR,CAAE;AACva;AACA;AACA,QAAQE,CAAC,CAACS,WAAF,KAAgBf,CAAC,CAACgB,MAAlB,GAAyBZ,CAAE,uDAA3B,GAAkFA,CAAE,yCAAyC;AACrI,QAAQE,CAAC,CAACO,4BAAF,GAA+BT,CAAE;AACzC;AACA,6JAFQ,GAEsJA,CAAE;AAChK,+DAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAhB+Z,CAAtL,IAgBjOG,CAAC,CAACK,GAAF,CAAMR,CAAE,8EAAR,CAhBiO;AAgB1I;;AAAA,SAASE,CAAT,CAAWN,CAAX,EAAaE,CAAb,EAAeE,CAAf,EAAiB;AAAC,MAAG,CAACF,CAAC,CAACe,cAAN,EAAqB;AAAO,QAAMZ,CAAC,GAACE,CAAC,CAACL,CAAC,CAACe,cAAH,EAAkBb,CAAC,CAACc,MAAF,CAASC,IAA3B,EAAgCf,CAAC,CAACc,MAAF,CAASE,YAAT,CAAsB,CAAtB,CAAhC,CAAT;AAAA,QAAmEd,CAAC,GAACF,CAAC,CAACc,MAAF,CAASG,UAAT,IAAqB,CAA1F;AAA4FrB,EAAAA,CAAC,CAACsB,YAAF,CAAe,gBAAf,EAAgCjB,CAAC,CAACkB,YAAF,GAAejB,CAA/C,EAAiDD,CAAC,CAACmB,WAAnD,EAA+DnB,CAAC,CAACoB,cAAjE,EAAgFpB,CAAC,CAACqB,cAAlF;AAAkG;;AAAA,SAASnB,CAAT,CAAWP,CAAX,EAAaE,CAAb,EAAeE,CAAf,EAAqB;AAAA,MAAJC,CAAI,uEAAFsB,CAAE;AAAC,SAAOtB,CAAC,CAACkB,YAAF,GAAevB,CAAC,CAACuB,YAAjB,EAA8BlB,CAAC,CAACmB,WAAF,GAAcI,IAAI,CAACC,GAAL,CAAS,KAAG3B,CAAZ,KAAgB,KAAGE,CAAnB,CAA5C,EAAkEC,CAAC,CAACoB,cAAF,GAAiBzB,CAAC,CAACyB,cAArF,EAAoGpB,CAAC,CAACqB,cAAF,GAAiB1B,CAAC,CAAC0B,cAAvH,EAAsIrB,CAA7I;AAA+I;;AAAA,MAAMsB,CAAC,GAAC;AAACJ,EAAAA,YAAY,EAAC,CAAd;AAAgBC,EAAAA,WAAW,EAAC,CAA5B;AAA8BC,EAAAA,cAAc,EAAC,CAA7C;AAA+CC,EAAAA,cAAc,EAAC;AAA9D,CAAR;AAAyE,SAAOrB,CAAC,IAAIyB,cAAZ,EAA2BxB,CAAC,IAAIyB,0BAAhC,EAA2DxB,CAAC,IAAIyB,8BAAhE","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.23/esri/copyright.txt for details.\n*/\nimport{ViewingMode as e}from\"../../../../../ViewingMode.js\";import{ScreenSizePerspective as r}from\"../util/ScreenSizePerspective.glsl.js\";import{glsl as t}from\"../../shaderModules/interfaces.js\";function l(l,c){const i=l.vertex.code;c.verticalOffsetEnabled?(l.vertex.uniforms.add(\"verticalOffset\",\"vec4\"),c.screenSizePerspectiveEnabled&&(l.include(r),l.vertex.uniforms.add(\"screenSizePerspectiveAlignment\",\"vec4\")),i.add(t`\n    vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);\n      ${c.viewingMode===e.Global?t`vec3 worldNormal = normalize(worldPos + localOrigin);`:t`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}\n      ${c.screenSizePerspectiveEnabled?t`\n          float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));\n          float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`:t`\n          float verticalOffsetScreenHeight = verticalOffset.x;`}\n      // Screen sized offset in world space, used for example for line callouts\n      float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\n      return worldNormal * worldOffset;\n    }\n\n    vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {\n      return worldPos + calculateVerticalOffset(worldPos, localOrigin);\n    }\n    `)):i.add(t`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)}function c(e,r,t){if(!r.verticalOffset)return;const l=i(r.verticalOffset,t.camera.fovY,t.camera.fullViewport[3]),c=t.camera.pixelRatio||1;e.setUniform4f(\"verticalOffset\",l.screenLength*c,l.perDistance,l.minWorldLength,l.maxWorldLength)}function i(e,r,t,l=o){return l.screenLength=e.screenLength,l.perDistance=Math.tan(.5*r)/(.5*t),l.minWorldLength=e.minWorldLength,l.maxWorldLength=e.maxWorldLength,l}const o={screenLength:0,perDistance:0,minWorldLength:0,maxWorldLength:0};export{l as VerticalOffset,c as bindVerticalOffsetUniforms,i as calculateVerticalOffsetFactors};\n"]},"metadata":{},"sourceType":"module"}