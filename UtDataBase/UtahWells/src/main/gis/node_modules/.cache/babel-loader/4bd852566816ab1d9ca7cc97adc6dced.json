{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.23/esri/copyright.txt for details.\n*/\nimport { ViewingMode as i } from \"../../../../../ViewingMode.js\";\nimport { EvaluateAmbientLighting as n } from \"./EvaluateAmbientLighting.glsl.js\";\nimport { EvaluateAmbientOcclusion as o } from \"./EvaluateAmbientOcclusion.glsl.js\";\nimport { EvaluateMainLighting as e } from \"./EvaluateMainLighting.glsl.js\";\nimport { PhysicallyBasedRendering as t } from \"./PhysicallyBasedRendering.glsl.js\";\nimport { PBRMode as a } from \"./PhysicallyBasedRenderingParameters.glsl.js\";\nimport { PiUtils as r } from \"./PiUtils.glsl.js\";\nimport { ReadShadowMap as l } from \"./ReadShadowMap.glsl.js\";\nimport { glsl as d } from \"../../shaderModules/interfaces.js\";\n\nfunction c(c, m) {\n  const s = c.fragment;\n  c.include(e), c.include(o, m), m.pbrMode !== a.Disabled && c.include(t, m), c.include(n, m), m.receiveShadows && c.include(l, m), s.uniforms.add(\"lightingGlobalFactor\", \"float\"), s.uniforms.add(\"ambientBoostFactor\", \"float\"), s.uniforms.add(\"hasFillLights\", \"bool\"), c.include(r), s.code.add(d`\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${m.pbrMode === a.Disabled ? \"\" : \"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `), s.code.add(d`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${m.viewingMode === i.Global ? d`normalize(vPosWorld)` : d`vec3(0.0, 0.0, 1.0)`}, lightingMainDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `), s.code.add(d`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n}`), m.pbrMode === a.Disabled || m.pbrMode === a.WaterOnIntegratedMesh ? s.code.add(d`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)\n{\nvec3 mainLighting = evaluateMainLighting(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`) : m.pbrMode !== a.Normal && m.pbrMode !== a.Schematic || (s.code.add(d`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 mainLightDirection = lightingMainDirection;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\ninputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), s.code.add(d`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), s.code.add(d`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;\nvec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), s.code.add(d`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nvec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;\ninputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\ninputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), s.code.add(d`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${m.pbrMode === a.Schematic ? d`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));` : d`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `));\n}\n\nexport { c as EvaluateSceneLighting };","map":{"version":3,"sources":["D:/Github/CUSP_DataBase/CUSP_DB/src/main/gis/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js"],"names":["ViewingMode","i","EvaluateAmbientLighting","n","EvaluateAmbientOcclusion","o","EvaluateMainLighting","e","PhysicallyBasedRendering","t","PBRMode","a","PiUtils","r","ReadShadowMap","l","glsl","d","c","m","s","fragment","include","pbrMode","Disabled","receiveShadows","uniforms","add","code","viewingMode","Global","WaterOnIntegratedMesh","Normal","Schematic","EvaluateSceneLighting"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,WAAW,IAAIC,CAAtB,QAA4B,+BAA5B;AAA4D,SAAOC,uBAAuB,IAAIC,CAAlC,QAAwC,mCAAxC;AAA4E,SAAOC,wBAAwB,IAAIC,CAAnC,QAAyC,oCAAzC;AAA8E,SAAOC,oBAAoB,IAAIC,CAA/B,QAAqC,gCAArC;AAAsE,SAAOC,wBAAwB,IAAIC,CAAnC,QAAyC,oCAAzC;AAA8E,SAAOC,OAAO,IAAIC,CAAlB,QAAwB,8CAAxB;AAAuE,SAAOC,OAAO,IAAIC,CAAlB,QAAwB,mBAAxB;AAA4C,SAAOC,aAAa,IAAIC,CAAxB,QAA8B,yBAA9B;AAAwD,SAAOC,IAAI,IAAIC,CAAf,QAAqB,mCAArB;;AAAyD,SAASC,CAAT,CAAWA,CAAX,EAAaC,CAAb,EAAe;AAAC,QAAMC,CAAC,GAACF,CAAC,CAACG,QAAV;AAAmBH,EAAAA,CAAC,CAACI,OAAF,CAAUf,CAAV,GAAaW,CAAC,CAACI,OAAF,CAAUjB,CAAV,EAAYc,CAAZ,CAAb,EAA4BA,CAAC,CAACI,OAAF,KAAYZ,CAAC,CAACa,QAAd,IAAwBN,CAAC,CAACI,OAAF,CAAUb,CAAV,EAAYU,CAAZ,CAApD,EAAmED,CAAC,CAACI,OAAF,CAAUnB,CAAV,EAAYgB,CAAZ,CAAnE,EAAkFA,CAAC,CAACM,cAAF,IAAkBP,CAAC,CAACI,OAAF,CAAUP,CAAV,EAAYI,CAAZ,CAApG,EAAmHC,CAAC,CAACM,QAAF,CAAWC,GAAX,CAAe,sBAAf,EAAsC,OAAtC,CAAnH,EAAkKP,CAAC,CAACM,QAAF,CAAWC,GAAX,CAAe,oBAAf,EAAoC,OAApC,CAAlK,EAA+MP,CAAC,CAACM,QAAF,CAAWC,GAAX,CAAe,eAAf,EAA+B,MAA/B,CAA/M,EAAsPT,CAAC,CAACI,OAAF,CAAUT,CAAV,CAAtP,EAAmQO,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWV,CAAE;AACj4B;AACA;AACA,MAAME,CAAC,CAACI,OAAF,KAAYZ,CAAC,CAACa,QAAd,GAAuB,EAAvB,GAA0B,4CAA6C;AAC7E,GAJo3B,CAAnQ,EAI5mBJ,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWV,CAAE;AAClB;AACA,yBAAyBE,CAAC,CAACU,WAAF,KAAgB5B,CAAC,CAAC6B,MAAlB,GAAyBb,CAAE,sBAA3B,GAAiDA,CAAE,qBAAqB;AACjG;AACA;AACA,GALK,CAJ4mB,EAS5mBG,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWV,CAAE;AAClB;AACA;AACA,EAHK,CAT4mB,EAY7mBE,CAAC,CAACI,OAAF,KAAYZ,CAAC,CAACa,QAAd,IAAwBL,CAAC,CAACI,OAAF,KAAYZ,CAAC,CAACoB,qBAAtC,GAA4DX,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWV,CAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EATgE,CAA5D,GASAE,CAAC,CAACI,OAAF,KAAYZ,CAAC,CAACqB,MAAd,IAAsBb,CAAC,CAACI,OAAF,KAAYZ,CAAC,CAACsB,SAApC,KAAgDb,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWV,CAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAnBoD,GAmBMG,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWV,CAAE;AACvE;AACA,gGAF0D,CAnBN,EAqB8CG,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWV,CAAE;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA,yJAPkG,CArB9C,EA4BuGG,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWV,CAAE;AACxK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAR2J,CA5BvG,EAoCkDG,CAAC,CAACQ,IAAF,CAAOD,GAAP,CAAWV,CAAE;AACnH;AACA;AACA;AACA;AACA,UAAUE,CAAC,CAACI,OAAF,KAAYZ,CAAC,CAACsB,SAAd,GAAwBhB,CAAE,oHAA1B,GAA8IA,CAAE,+FAA+F;AACzP;AACA;AACA,KARsG,CApClG,CArB6mB;AAiEzmB;;AAAA,SAAOC,CAAC,IAAIgB,qBAAZ","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.23/esri/copyright.txt for details.\n*/\nimport{ViewingMode as i}from\"../../../../../ViewingMode.js\";import{EvaluateAmbientLighting as n}from\"./EvaluateAmbientLighting.glsl.js\";import{EvaluateAmbientOcclusion as o}from\"./EvaluateAmbientOcclusion.glsl.js\";import{EvaluateMainLighting as e}from\"./EvaluateMainLighting.glsl.js\";import{PhysicallyBasedRendering as t}from\"./PhysicallyBasedRendering.glsl.js\";import{PBRMode as a}from\"./PhysicallyBasedRenderingParameters.glsl.js\";import{PiUtils as r}from\"./PiUtils.glsl.js\";import{ReadShadowMap as l}from\"./ReadShadowMap.glsl.js\";import{glsl as d}from\"../../shaderModules/interfaces.js\";function c(c,m){const s=c.fragment;c.include(e),c.include(o,m),m.pbrMode!==a.Disabled&&c.include(t,m),c.include(n,m),m.receiveShadows&&c.include(l,m),s.uniforms.add(\"lightingGlobalFactor\",\"float\"),s.uniforms.add(\"ambientBoostFactor\",\"float\"),s.uniforms.add(\"hasFillLights\",\"bool\"),c.include(r),s.code.add(d`\n    const float GAMMA_SRGB = 2.1;\n    const float INV_GAMMA_SRGB = 0.4761904;\n    ${m.pbrMode===a.Disabled?\"\":\"const vec3 GROUND_REFLECTANCE = vec3(0.2);\"}\n  `),s.code.add(d`\n    float additionalDirectedAmbientLight(vec3 vPosWorld) {\n      float vndl = dot(${m.viewingMode===i.Global?d`normalize(vPosWorld)`:d`vec3(0.0, 0.0, 1.0)`}, lightingMainDirection);\n      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\n    }\n  `),s.code.add(d`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {\nfloat additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);\nreturn (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * lightingMainIntensity;\n}`),m.pbrMode===a.Disabled||m.pbrMode===a.WaterOnIntegratedMesh?s.code.add(d`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)\n{\nvec3 mainLighting = evaluateMainLighting(normalWorld, shadow);\nvec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);\nvec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\nvec3 totalLight = mainLighting + ambientLighting + additionalLight;\ntotalLight = min(totalLight, vec3(PI));\nvec3 outColor = vec3((albedoLinear / PI) * totalLight);\nreturn pow(outColor, vec3(INV_GAMMA_SRGB));\n}`):m.pbrMode!==a.Normal&&m.pbrMode!==a.Schematic||(s.code.add(d`const float fillLightIntensity = 0.25;\nconst float horizonLightDiffusion = 0.4;\nconst float additionalAmbientIrradianceFactor = 0.02;\nvec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)\n{\nvec3 viewDirection = -viewDir;\nvec3 mainLightDirection = lightingMainDirection;\nvec3 h = normalize(viewDirection + mainLightDirection);\nPBRShadingInfo inputs;\ninputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);\ninputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);\ninputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);\ninputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);\ninputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);\nvec3 reflectedView = normalize(reflect(viewDirection, normal));\ninputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);\ninputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));\ninputs.ssao = ssao;\ninputs.metalness = mrr[0];\ninputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`),s.code.add(d`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;\ninputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));\ninputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`),s.code.add(d`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);\nambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));\ninputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;\nvec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * lightingMainIntensity;\nvec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;\ninputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;\ninputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`),s.code.add(d`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;\nvec3 horizonRingH = normalize(viewDirection + horizonRingDir);\ninputs.NdotH_Horizon = dot(normal, horizonRingH);\nvec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * lightingMainIntensity * (1.0 - shadow);\nvec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * lightingMainIntensity * fillLightIntensity;\nvec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;\ninputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;\ninputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;\ninputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`),s.code.add(d`\n        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);\n        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;\n        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));\n        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;\n        ${m.pbrMode===a.Schematic?d`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`:d`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}\n        return outColor;\n      }\n    `))}export{c as EvaluateSceneLighting};\n"]},"metadata":{},"sourceType":"module"}