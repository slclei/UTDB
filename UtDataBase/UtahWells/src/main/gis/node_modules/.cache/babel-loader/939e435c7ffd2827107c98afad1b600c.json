{"ast":null,"code":"/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.23/esri/copyright.txt for details.\n*/\nimport { TextureCoordinateAttributeType as e } from \"../attributes/TextureCoordinateAttribute.glsl.js\";\nimport { VertexTextureCoordinates as t } from \"../attributes/VertexTextureCoordinates.glsl.js\";\nimport { NormalsDoubleSidedMode as n } from \"./Normals.glsl.js\";\nimport { glsl as a } from \"../../shaderModules/interfaces.js\";\nimport { VertexAttribute as r } from \"../../../lib/VertexAttribute.js\";\n\nfunction o(o, s) {\n  const d = o.fragment;\n  s.vertexTangents ? (o.attributes.add(r.TANGENT, \"vec4\"), o.varyings.add(\"vTangent\", \"vec4\"), s.doubleSidedMode === n.WindingOrder ? d.code.add(a`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\nvec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`) : d.code.add(a`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = vTangent.w;\nvec3 tangent = normalize(vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`)) : (o.extensions.add(\"GL_OES_standard_derivatives\"), d.code.add(a`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\nvec3 Q1 = dFdx(pos);\nvec3 Q2 = dFdy(pos);\nvec2 stx = dFdx(st);\nvec2 sty = dFdy(st);\nfloat det = stx.t * sty.s - sty.t * stx.s;\nvec3 T = stx.t * Q2 - sty.t * Q1;\nT = T - normal * dot(normal, T);\nT *= inversesqrt(max(dot(T,T), 1.e-10));\nvec3 B = sign(det) * cross(normal, T);\nreturn mat3(T, B, normal);\n}`)), s.attributeTextureCoordinates !== e.None && (o.include(t, s), d.uniforms.add(\"normalTexture\", \"sampler2D\"), d.uniforms.add(\"normalTextureSize\", \"vec2\"), d.code.add(a`\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ${s.supportsTextureAtlas ? \"vtc.size = normalTextureSize;\" : \"\"}\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  `));\n}\n\nexport { o as ComputeNormalTexture };","map":{"version":3,"sources":["D:/Github/CUSP_DataBase/CUSP_DB/src/main/gis/node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js"],"names":["TextureCoordinateAttributeType","e","VertexTextureCoordinates","t","NormalsDoubleSidedMode","n","glsl","a","VertexAttribute","r","o","s","d","fragment","vertexTangents","attributes","add","TANGENT","varyings","doubleSidedMode","WindingOrder","code","extensions","attributeTextureCoordinates","None","include","uniforms","supportsTextureAtlas","ComputeNormalTexture"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAAOA,8BAA8B,IAAIC,CAAzC,QAA+C,kDAA/C;AAAkG,SAAOC,wBAAwB,IAAIC,CAAnC,QAAyC,gDAAzC;AAA0F,SAAOC,sBAAsB,IAAIC,CAAjC,QAAuC,mBAAvC;AAA2D,SAAOC,IAAI,IAAIC,CAAf,QAAqB,mCAArB;AAAyD,SAAOC,eAAe,IAAIC,CAA1B,QAAgC,iCAAhC;;AAAkE,SAASC,CAAT,CAAWA,CAAX,EAAaC,CAAb,EAAe;AAAC,QAAMC,CAAC,GAACF,CAAC,CAACG,QAAV;AAAmBF,EAAAA,CAAC,CAACG,cAAF,IAAkBJ,CAAC,CAACK,UAAF,CAAaC,GAAb,CAAiBP,CAAC,CAACQ,OAAnB,EAA2B,MAA3B,GAAmCP,CAAC,CAACQ,QAAF,CAAWF,GAAX,CAAe,UAAf,EAA0B,MAA1B,CAAnC,EAAqEL,CAAC,CAACQ,eAAF,KAAoBd,CAAC,CAACe,YAAtB,GAAmCR,CAAC,CAACS,IAAF,CAAOL,GAAP,CAAWT,CAAE;AAC5hB;AACA;AACA;AACA;AACA,EAL+gB,CAAnC,GAKxeK,CAAC,CAACS,IAAF,CAAOL,GAAP,CAAWT,CAAE;AACjB;AACA;AACA;AACA;AACA,EALI,CALiZ,KAU/YG,CAAC,CAACY,UAAF,CAAaN,GAAb,CAAiB,6BAAjB,GAAgDJ,CAAC,CAACS,IAAF,CAAOL,GAAP,CAAWT,CAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAXsD,CAV+V,GAqBhZI,CAAC,CAACY,2BAAF,KAAgCtB,CAAC,CAACuB,IAAlC,KAAyCd,CAAC,CAACe,OAAF,CAAUtB,CAAV,EAAYQ,CAAZ,GAAeC,CAAC,CAACc,QAAF,CAAWV,GAAX,CAAe,eAAf,EAA+B,WAA/B,CAAf,EAA2DJ,CAAC,CAACc,QAAF,CAAWV,GAAX,CAAe,mBAAf,EAAmC,MAAnC,CAA3D,EAAsGJ,CAAC,CAACS,IAAF,CAAOL,GAAP,CAAWT,CAAE;AACjK;AACA;AACA,QAAQI,CAAC,CAACgB,oBAAF,GAAuB,+BAAvB,GAAuD,EAAG;AAClE;AACA;AACA;AACA,GAPoJ,CAA/I,CArBgZ;AA4B/Y;;AAAA,SAAOjB,CAAC,IAAIkB,oBAAZ","sourcesContent":["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.23/esri/copyright.txt for details.\n*/\nimport{TextureCoordinateAttributeType as e}from\"../attributes/TextureCoordinateAttribute.glsl.js\";import{VertexTextureCoordinates as t}from\"../attributes/VertexTextureCoordinates.glsl.js\";import{NormalsDoubleSidedMode as n}from\"./Normals.glsl.js\";import{glsl as a}from\"../../shaderModules/interfaces.js\";import{VertexAttribute as r}from\"../../../lib/VertexAttribute.js\";function o(o,s){const d=o.fragment;s.vertexTangents?(o.attributes.add(r.TANGENT,\"vec4\"),o.varyings.add(\"vTangent\",\"vec4\"),s.doubleSidedMode===n.WindingOrder?d.code.add(a`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;\nvec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`):d.code.add(a`mat3 computeTangentSpace(vec3 normal) {\nfloat tangentHeadedness = vTangent.w;\nvec3 tangent = normalize(vTangent.xyz);\nvec3 bitangent = cross(normal, tangent) * tangentHeadedness;\nreturn mat3(tangent, bitangent, normal);\n}`)):(o.extensions.add(\"GL_OES_standard_derivatives\"),d.code.add(a`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {\nvec3 Q1 = dFdx(pos);\nvec3 Q2 = dFdy(pos);\nvec2 stx = dFdx(st);\nvec2 sty = dFdy(st);\nfloat det = stx.t * sty.s - sty.t * stx.s;\nvec3 T = stx.t * Q2 - sty.t * Q1;\nT = T - normal * dot(normal, T);\nT *= inversesqrt(max(dot(T,T), 1.e-10));\nvec3 B = sign(det) * cross(normal, T);\nreturn mat3(T, B, normal);\n}`)),s.attributeTextureCoordinates!==e.None&&(o.include(t,s),d.uniforms.add(\"normalTexture\",\"sampler2D\"),d.uniforms.add(\"normalTextureSize\",\"vec2\"),d.code.add(a`\n    vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {\n      vtc.uv = uv;\n      ${s.supportsTextureAtlas?\"vtc.size = normalTextureSize;\":\"\"}\n      vec3 rawNormal = textureLookup(normalTexture, vtc).rgb * 2.0 - 1.0;\n      return tangentSpace * rawNormal;\n    }\n  `))}export{o as ComputeNormalTexture};\n"]},"metadata":{},"sourceType":"module"}