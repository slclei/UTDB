{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.printDiffLines = exports.diffLinesUnified2 = exports.diffLinesUnified = exports.diffLinesRaw = void 0;\n\nvar _diffSequences = _interopRequireDefault(require('diff-sequences'));\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\n\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst isEmptyString = lines => lines.length === 1 && lines[0].length === 0;\n\nconst countChanges = diffs => {\n  let a = 0;\n  let b = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        a += 1;\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  });\n  return {\n    a,\n    b\n  };\n};\n\nconst printAnnotation = (_ref, changeCounts) => {\n  let {\n    aAnnotation,\n    aColor,\n    aIndicator,\n    bAnnotation,\n    bColor,\n    bIndicator,\n    includeChangeCounts,\n    omitAnnotationLines\n  } = _ref;\n\n  if (omitAnnotationLines) {\n    return '';\n  }\n\n  let aRest = '';\n  let bRest = '';\n\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b); // Padding right aligns the ends of the annotations.\n\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff)); // Padding left aligns the ends of the counts.\n\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));\n    aRest = aAnnotationPadding + '  ' + aIndicator + ' ' + aCountPadding + aCount;\n    bRest = bAnnotationPadding + '  ' + bIndicator + ' ' + bCountPadding + bCount;\n  }\n\n  return aColor(aIndicator + ' ' + aAnnotation + aRest) + '\\n' + bColor(bIndicator + ' ' + bAnnotation + bRest) + '\\n\\n';\n};\n\nconst printDiffLines = (diffs, options) => printAnnotation(options, countChanges(diffs)) + (options.expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options)); // Compare two arrays of strings line-by-line. Format as comparison lines.\n\n\nexports.printDiffLines = printDiffLines;\n\nconst diffLinesUnified = (aLines, bLines, options) => printDiffLines(diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines), (0, _normalizeDiffOptions.normalizeDiffOptions)(options)); // Given two pairs of arrays of strings:\n// Compare the pair of comparison arrays line-by-line.\n// Format the corresponding lines in the pair of displayable arrays.\n\n\nexports.diffLinesUnified = diffLinesUnified;\n\nconst diffLinesUnified2 = (aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) => {\n  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n    aLinesDisplay = [];\n    aLinesCompare = [];\n  }\n\n  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n    bLinesDisplay = [];\n    bLinesCompare = [];\n  }\n\n  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {\n    // Fall back to diff of display lines.\n    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n  }\n\n  const diffs = diffLinesRaw(aLinesCompare, bLinesCompare); // Replace comparison lines with displayable lines.\n\n  let aIndex = 0;\n  let bIndex = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        diff[1] = aLinesDisplay[aIndex];\n        aIndex += 1;\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        diff[1] = bLinesDisplay[bIndex];\n        bIndex += 1;\n        break;\n\n      default:\n        diff[1] = bLinesDisplay[bIndex];\n        aIndex += 1;\n        bIndex += 1;\n    }\n  });\n  return printDiffLines(diffs, (0, _normalizeDiffOptions.normalizeDiffOptions)(options));\n}; // Compare two arrays of strings line-by-line.\n\n\nexports.diffLinesUnified2 = diffLinesUnified2;\n\nconst diffLinesRaw = (aLines, bLines) => {\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  const diffs = [];\n  let aIndex = 0;\n  let bIndex = 0;\n\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));\n    }\n\n    for (; bIndex !== bCommon; bIndex += 1) {\n      diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));\n    }\n\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, bLines[bIndex]));\n    }\n  };\n\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // After the last common subsequence, push remaining change items.\n\n  for (; aIndex !== aLength; aIndex += 1) {\n    diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex]));\n  }\n\n  for (; bIndex !== bLength; bIndex += 1) {\n    diffs.push(new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex]));\n  }\n\n  return diffs;\n};\n\nexports.diffLinesRaw = diffLinesRaw;","map":{"version":3,"sources":["D:/Github/CUSP_DataBase/CUSP_DB/src/main/mapbox-project/node_modules/jest-diff/build/diffLines.js"],"names":["Object","defineProperty","exports","value","printDiffLines","diffLinesUnified2","diffLinesUnified","diffLinesRaw","_diffSequences","_interopRequireDefault","require","_cleanupSemantic","_joinAlignedDiffs","_normalizeDiffOptions","obj","__esModule","default","isEmptyString","lines","length","countChanges","diffs","a","b","forEach","diff","DIFF_DELETE","DIFF_INSERT","printAnnotation","changeCounts","aAnnotation","aColor","aIndicator","bAnnotation","bColor","bIndicator","includeChangeCounts","omitAnnotationLines","aRest","bRest","aCount","String","bCount","baAnnotationLengthDiff","aAnnotationPadding","repeat","Math","max","bAnnotationPadding","baCountLengthDiff","aCountPadding","bCountPadding","options","expand","joinAlignedDiffsExpand","joinAlignedDiffsNoExpand","aLines","bLines","normalizeDiffOptions","aLinesDisplay","bLinesDisplay","aLinesCompare","bLinesCompare","aIndex","bIndex","aLength","bLength","isCommon","foundSubsequence","nCommon","aCommon","bCommon","push","Diff","DIFF_EQUAL"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.printDiffLines =\n  exports.diffLinesUnified2 =\n  exports.diffLinesUnified =\n  exports.diffLinesRaw =\n    void 0;\n\nvar _diffSequences = _interopRequireDefault(require('diff-sequences'));\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _joinAlignedDiffs = require('./joinAlignedDiffs');\n\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst isEmptyString = lines => lines.length === 1 && lines[0].length === 0;\n\nconst countChanges = diffs => {\n  let a = 0;\n  let b = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        a += 1;\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  });\n  return {\n    a,\n    b\n  };\n};\n\nconst printAnnotation = (\n  {\n    aAnnotation,\n    aColor,\n    aIndicator,\n    bAnnotation,\n    bColor,\n    bIndicator,\n    includeChangeCounts,\n    omitAnnotationLines\n  },\n  changeCounts\n) => {\n  if (omitAnnotationLines) {\n    return '';\n  }\n\n  let aRest = '';\n  let bRest = '';\n\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b); // Padding right aligns the ends of the annotations.\n\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff)); // Padding left aligns the ends of the counts.\n\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));\n    aRest =\n      aAnnotationPadding + '  ' + aIndicator + ' ' + aCountPadding + aCount;\n    bRest =\n      bAnnotationPadding + '  ' + bIndicator + ' ' + bCountPadding + bCount;\n  }\n\n  return (\n    aColor(aIndicator + ' ' + aAnnotation + aRest) +\n    '\\n' +\n    bColor(bIndicator + ' ' + bAnnotation + bRest) +\n    '\\n\\n'\n  );\n};\n\nconst printDiffLines = (diffs, options) =>\n  printAnnotation(options, countChanges(diffs)) +\n  (options.expand\n    ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options)\n    : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options)); // Compare two arrays of strings line-by-line. Format as comparison lines.\n\nexports.printDiffLines = printDiffLines;\n\nconst diffLinesUnified = (aLines, bLines, options) =>\n  printDiffLines(\n    diffLinesRaw(\n      isEmptyString(aLines) ? [] : aLines,\n      isEmptyString(bLines) ? [] : bLines\n    ),\n    (0, _normalizeDiffOptions.normalizeDiffOptions)(options)\n  ); // Given two pairs of arrays of strings:\n// Compare the pair of comparison arrays line-by-line.\n// Format the corresponding lines in the pair of displayable arrays.\n\nexports.diffLinesUnified = diffLinesUnified;\n\nconst diffLinesUnified2 = (\n  aLinesDisplay,\n  bLinesDisplay,\n  aLinesCompare,\n  bLinesCompare,\n  options\n) => {\n  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n    aLinesDisplay = [];\n    aLinesCompare = [];\n  }\n\n  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n    bLinesDisplay = [];\n    bLinesCompare = [];\n  }\n\n  if (\n    aLinesDisplay.length !== aLinesCompare.length ||\n    bLinesDisplay.length !== bLinesCompare.length\n  ) {\n    // Fall back to diff of display lines.\n    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n  }\n\n  const diffs = diffLinesRaw(aLinesCompare, bLinesCompare); // Replace comparison lines with displayable lines.\n\n  let aIndex = 0;\n  let bIndex = 0;\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        diff[1] = aLinesDisplay[aIndex];\n        aIndex += 1;\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        diff[1] = bLinesDisplay[bIndex];\n        bIndex += 1;\n        break;\n\n      default:\n        diff[1] = bLinesDisplay[bIndex];\n        aIndex += 1;\n        bIndex += 1;\n    }\n  });\n  return printDiffLines(\n    diffs,\n    (0, _normalizeDiffOptions.normalizeDiffOptions)(options)\n  );\n}; // Compare two arrays of strings line-by-line.\n\nexports.diffLinesUnified2 = diffLinesUnified2;\n\nconst diffLinesRaw = (aLines, bLines) => {\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  const diffs = [];\n  let aIndex = 0;\n  let bIndex = 0;\n\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      diffs.push(\n        new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex])\n      );\n    }\n\n    for (; bIndex !== bCommon; bIndex += 1) {\n      diffs.push(\n        new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex])\n      );\n    }\n\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      diffs.push(\n        new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_EQUAL, bLines[bIndex])\n      );\n    }\n  };\n\n  (0, _diffSequences.default)(aLength, bLength, isCommon, foundSubsequence); // After the last common subsequence, push remaining change items.\n\n  for (; aIndex !== aLength; aIndex += 1) {\n    diffs.push(\n      new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_DELETE, aLines[aIndex])\n    );\n  }\n\n  for (; bIndex !== bLength; bIndex += 1) {\n    diffs.push(\n      new _cleanupSemantic.Diff(_cleanupSemantic.DIFF_INSERT, bLines[bIndex])\n    );\n  }\n\n  return diffs;\n};\n\nexports.diffLinesRaw = diffLinesRaw;\n"]},"metadata":{},"sourceType":"script"}