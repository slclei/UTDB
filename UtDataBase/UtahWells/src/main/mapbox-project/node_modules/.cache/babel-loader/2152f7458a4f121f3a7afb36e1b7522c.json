{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.diffStringsUnified = exports.diffStringsRaw = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffLines = require('./diffLines');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some((diff, i) => diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== '\\n'));\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n}; // Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\n\n\nconst diffStringsUnified = (a, b, options) => {\n  if (a !== b && a.length !== 0 && b.length !== 0) {\n    const isMultiline = a.includes('\\n') || b.includes('\\n'); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n    const diffs = diffStringsRaw(isMultiline ? a + '\\n' : a, isMultiline ? b + '\\n' : b, true // cleanupSemantic\n    );\n\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);\n      const lines = (0, _getAlignedDiffs.default)(diffs, optionsNormalized.changeColor);\n      return (0, _diffLines.printDiffLines)(lines, optionsNormalized);\n    }\n  } // Fall back to line-by-line diff.\n\n\n  return (0, _diffLines.diffLinesUnified)(a.split('\\n'), b.split('\\n'), options);\n}; // Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\n\n\nexports.diffStringsUnified = diffStringsUnified;\n\nconst diffStringsRaw = (a, b, cleanup) => {\n  const diffs = (0, _diffStrings.default)(a, b);\n\n  if (cleanup) {\n    (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n  }\n\n  return diffs;\n};\n\nexports.diffStringsRaw = diffStringsRaw;","map":{"version":3,"sources":["D:/Github/CUSP_DataBase/CUSP_DB/src/main/mapbox-project/node_modules/jest-diff/build/printDiffs.js"],"names":["Object","defineProperty","exports","value","diffStringsUnified","diffStringsRaw","_cleanupSemantic","require","_diffLines","_diffStrings","_interopRequireDefault","_getAlignedDiffs","_normalizeDiffOptions","obj","__esModule","default","hasCommonDiff","diffs","isMultiline","iLast","length","some","diff","i","DIFF_EQUAL","a","b","options","includes","optionsNormalized","normalizeDiffOptions","lines","changeColor","printDiffLines","diffLinesUnified","split","cleanup","cleanupSemantic"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.diffStringsUnified = exports.diffStringsRaw = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _diffLines = require('./diffLines');\n\nvar _diffStrings = _interopRequireDefault(require('./diffStrings'));\n\nvar _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));\n\nvar _normalizeDiffOptions = require('./normalizeDiffOptions');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst hasCommonDiff = (diffs, isMultiline) => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some(\n      (diff, i) =>\n        diff[0] === _cleanupSemantic.DIFF_EQUAL &&\n        (i !== iLast || diff[1] !== '\\n')\n    );\n  }\n\n  return diffs.some(diff => diff[0] === _cleanupSemantic.DIFF_EQUAL);\n}; // Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\n\nconst diffStringsUnified = (a, b, options) => {\n  if (a !== b && a.length !== 0 && b.length !== 0) {\n    const isMultiline = a.includes('\\n') || b.includes('\\n'); // getAlignedDiffs assumes that a newline was appended to the strings.\n\n    const diffs = diffStringsRaw(\n      isMultiline ? a + '\\n' : a,\n      isMultiline ? b + '\\n' : b,\n      true // cleanupSemantic\n    );\n\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(\n        options\n      );\n      const lines = (0, _getAlignedDiffs.default)(\n        diffs,\n        optionsNormalized.changeColor\n      );\n      return (0, _diffLines.printDiffLines)(lines, optionsNormalized);\n    }\n  } // Fall back to line-by-line diff.\n\n  return (0, _diffLines.diffLinesUnified)(\n    a.split('\\n'),\n    b.split('\\n'),\n    options\n  );\n}; // Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\n\nexports.diffStringsUnified = diffStringsUnified;\n\nconst diffStringsRaw = (a, b, cleanup) => {\n  const diffs = (0, _diffStrings.default)(a, b);\n\n  if (cleanup) {\n    (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function\n  }\n\n  return diffs;\n};\n\nexports.diffStringsRaw = diffStringsRaw;\n"]},"metadata":{},"sourceType":"script"}