{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.arrayBufferEquality = void 0;\nexports.emptyObject = emptyObject;\nexports.typeEquality = exports.subsetEquality = exports.sparseArrayEquality = exports.pathAsArray = exports.partition = exports.iterableEquality = exports.isOneline = exports.isError = exports.getPath = exports.getObjectSubset = void 0;\n\nvar _jestGetType = require('jest-get-type');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar global = function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n}();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n/**\n * Checks if `hasOwnProperty(object, key)` up the prototype chain, stopping at `Object.prototype`.\n */\n\nconst hasPropertyInObject = (object, key) => {\n  const shouldTerminate = !object || typeof object !== 'object' || object === Object.prototype;\n\n  if (shouldTerminate) {\n    return false;\n  }\n\n  return Object.prototype.hasOwnProperty.call(object, key) || hasPropertyInObject(Object.getPrototypeOf(object), key);\n};\n\nconst getPath = (object, propertyPath) => {\n  if (!Array.isArray(propertyPath)) {\n    propertyPath = pathAsArray(propertyPath);\n  }\n\n  if (propertyPath.length) {\n    const lastProp = propertyPath.length === 1;\n    const prop = propertyPath[0];\n    const newObject = object[prop];\n\n    if (!lastProp && (newObject === null || newObject === undefined)) {\n      // This is not the last prop in the chain. If we keep recursing it will\n      // hit a `can't access property X of undefined | null`. At this point we\n      // know that the chain has broken and we can return right away.\n      return {\n        hasEndProp: false,\n        lastTraversedObject: object,\n        traversedPath: []\n      };\n    }\n\n    const result = getPath(newObject, propertyPath.slice(1));\n\n    if (result.lastTraversedObject === null) {\n      result.lastTraversedObject = object;\n    }\n\n    result.traversedPath.unshift(prop);\n\n    if (lastProp) {\n      // Does object have the property with an undefined value?\n      // Although primitive values support bracket notation (above)\n      // they would throw TypeError for in operator (below).\n      result.hasEndProp = newObject !== undefined || !(0, _jestGetType.isPrimitive)(object) && prop in object;\n\n      if (!result.hasEndProp) {\n        result.traversedPath.shift();\n      }\n    }\n\n    return result;\n  }\n\n  return {\n    lastTraversedObject: null,\n    traversedPath: [],\n    value: object\n  };\n}; // Strip properties from object that are not present in the subset. Useful for\n// printing the diff for toMatchObject() without adding unrelated noise.\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\n\nexports.getPath = getPath;\n\nconst getObjectSubset = function (object, subset) {\n  let seenReferences = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new WeakMap();\n\n  /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n  if (Array.isArray(object)) {\n    if (Array.isArray(subset) && subset.length === object.length) {\n      // The map method returns correct subclass of subset.\n      return subset.map((sub, i) => getObjectSubset(object[i], sub));\n    }\n  } else if (object instanceof Date) {\n    return object;\n  } else if (isObject(object) && isObject(subset)) {\n    if ((0, _jasmineUtils.equals)(object, subset, [iterableEquality, subsetEquality])) {\n      // Avoid unnecessary copy which might return Object instead of subclass.\n      return subset;\n    }\n\n    const trimmed = {};\n    seenReferences.set(object, trimmed);\n    Object.keys(object).filter(key => hasPropertyInObject(subset, key)).forEach(key => {\n      trimmed[key] = seenReferences.has(object[key]) ? seenReferences.get(object[key]) : getObjectSubset(object[key], subset[key], seenReferences);\n    });\n\n    if (Object.keys(trimmed).length > 0) {\n      return trimmed;\n    }\n  }\n\n  return object;\n};\n\nexports.getObjectSubset = getObjectSubset;\nconst IteratorSymbol = Symbol.iterator;\n\nconst hasIterator = object => !!(object != null && object[IteratorSymbol]);\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\n\nconst iterableEquality = function (a, b) {\n  let aStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let bStack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  if (typeof a !== 'object' || typeof b !== 'object' || Array.isArray(a) || Array.isArray(b) || !hasIterator(a) || !hasIterator(b)) {\n    return undefined;\n  }\n\n  if (a.constructor !== b.constructor) {\n    return false;\n  }\n\n  let length = aStack.length;\n\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    // circular references at same depth are equal\n    // circular reference is not equal to non-circular one\n    if (aStack[length] === a) {\n      return bStack[length] === b;\n    }\n  }\n\n  aStack.push(a);\n  bStack.push(b);\n\n  const iterableEqualityWithStack = (a, b) => iterableEquality(a, b, [...aStack], [...bStack]);\n\n  if (a.size !== undefined) {\n    if (a.size !== b.size) {\n      return false;\n    } else if ((0, _jasmineUtils.isA)('Set', a) || (0, _jasmineUtils.isImmutableUnorderedSet)(a)) {\n      let allFound = true;\n\n      for (const aValue of a) {\n        if (!b.has(aValue)) {\n          let has = false;\n\n          for (const bValue of b) {\n            const isEqual = (0, _jasmineUtils.equals)(aValue, bValue, [iterableEqualityWithStack]);\n\n            if (isEqual === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      } // Remove the first value from the stack of traversed values.\n\n\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    } else if ((0, _jasmineUtils.isA)('Map', a) || (0, _jasmineUtils.isImmutableUnorderedKeyed)(a)) {\n      let allFound = true;\n\n      for (const aEntry of a) {\n        if (!b.has(aEntry[0]) || !(0, _jasmineUtils.equals)(aEntry[1], b.get(aEntry[0]), [iterableEqualityWithStack])) {\n          let has = false;\n\n          for (const bEntry of b) {\n            const matchedKey = (0, _jasmineUtils.equals)(aEntry[0], bEntry[0], [iterableEqualityWithStack]);\n            let matchedValue = false;\n\n            if (matchedKey === true) {\n              matchedValue = (0, _jasmineUtils.equals)(aEntry[1], bEntry[1], [iterableEqualityWithStack]);\n            }\n\n            if (matchedValue === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      } // Remove the first value from the stack of traversed values.\n\n\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    }\n  }\n\n  const bIterator = b[IteratorSymbol]();\n\n  for (const aValue of a) {\n    const nextB = bIterator.next();\n\n    if (nextB.done || !(0, _jasmineUtils.equals)(aValue, nextB.value, [iterableEqualityWithStack])) {\n      return false;\n    }\n  }\n\n  if (!bIterator.next().done) {\n    return false;\n  } // Remove the first value from the stack of traversed values.\n\n\n  aStack.pop();\n  bStack.pop();\n  return true;\n};\n\nexports.iterableEquality = iterableEquality;\n\nconst isObject = a => a !== null && typeof a === 'object';\n\nconst isObjectWithKeys = a => isObject(a) && !(a instanceof Error) && !(a instanceof Array) && !(a instanceof Date);\n\nconst subsetEquality = (object, subset) => {\n  // subsetEquality needs to keep track of the references\n  // it has already visited to avoid infinite loops in case\n  // there are circular references in the subset passed to it.\n  const subsetEqualityWithContext = function () {\n    let seenReferences = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new WeakMap();\n    return (object, subset) => {\n      if (!isObjectWithKeys(subset)) {\n        return undefined;\n      }\n\n      return Object.keys(subset).every(key => {\n        if (isObjectWithKeys(subset[key])) {\n          if (seenReferences.has(subset[key])) {\n            return (0, _jasmineUtils.equals)(object[key], subset[key], [iterableEquality]);\n          }\n\n          seenReferences.set(subset[key], true);\n        }\n\n        const result = object != null && hasPropertyInObject(object, key) && (0, _jasmineUtils.equals)(object[key], subset[key], [iterableEquality, subsetEqualityWithContext(seenReferences)]); // The main goal of using seenReference is to avoid circular node on tree.\n        // It will only happen within a parent and its child, not a node and nodes next to it (same level)\n        // We should keep the reference for a parent and its child only\n        // Thus we should delete the reference immediately so that it doesn't interfere\n        // other nodes within the same level on tree.\n\n        seenReferences.delete(subset[key]);\n        return result;\n      });\n    };\n  };\n\n  return subsetEqualityWithContext()(object, subset);\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\n\nexports.subsetEquality = subsetEquality;\n\nconst typeEquality = (a, b) => {\n  if (a == null || b == null || a.constructor === b.constructor) {\n    return undefined;\n  }\n\n  return false;\n};\n\nexports.typeEquality = typeEquality;\n\nconst arrayBufferEquality = (a, b) => {\n  if (!(a instanceof ArrayBuffer) || !(b instanceof ArrayBuffer)) {\n    return undefined;\n  }\n\n  const dataViewA = new DataView(a);\n  const dataViewB = new DataView(b); // Buffers are not equal when they do not have the same byte length\n\n  if (dataViewA.byteLength !== dataViewB.byteLength) {\n    return false;\n  } // Check if every byte value is equal to each other\n\n\n  for (let i = 0; i < dataViewA.byteLength; i++) {\n    if (dataViewA.getUint8(i) !== dataViewB.getUint8(i)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexports.arrayBufferEquality = arrayBufferEquality;\n\nconst sparseArrayEquality = (a, b) => {\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    return undefined;\n  } // A sparse array [, , 1] will have keys [\"2\"] whereas [undefined, undefined, 1] will have keys [\"0\", \"1\", \"2\"]\n\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  return (0, _jasmineUtils.equals)(a, b, [iterableEquality, typeEquality], true) && (0, _jasmineUtils.equals)(aKeys, bKeys);\n};\n\nexports.sparseArrayEquality = sparseArrayEquality;\n\nconst partition = (items, predicate) => {\n  const result = [[], []];\n  items.forEach(item => result[predicate(item) ? 0 : 1].push(item));\n  return result;\n};\n\nexports.partition = partition;\n\nconst pathAsArray = propertyPath => {\n  const properties = [];\n\n  if (propertyPath === '') {\n    properties.push('');\n    return properties;\n  } // will match everything that's not a dot or a bracket, and \"\" for consecutive dots.\n\n\n  const pattern = RegExp('[^.[\\\\]]+|(?=(?:\\\\.)(?:\\\\.|$))', 'g'); // Because the regex won't match a dot in the beginning of the path, if present.\n\n  if (propertyPath[0] === '.') {\n    properties.push('');\n  }\n\n  propertyPath.replace(pattern, match => {\n    properties.push(match);\n    return match;\n  });\n  return properties;\n}; // Copied from https://github.com/graingert/angular.js/blob/a43574052e9775cbc1d7dd8a086752c979b0f020/src/Angular.js#L685-L693\n\n\nexports.pathAsArray = pathAsArray;\n\nconst isError = value => {\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n      return true;\n\n    default:\n      return value instanceof Error;\n  }\n};\n\nexports.isError = isError;\n\nfunction emptyObject(obj) {\n  return obj && typeof obj === 'object' ? !Object.keys(obj).length : false;\n}\n\nconst MULTILINE_REGEXP = /[\\r\\n]/;\n\nconst isOneline = (expected, received) => typeof expected === 'string' && typeof received === 'string' && (!MULTILINE_REGEXP.test(expected) || !MULTILINE_REGEXP.test(received));\n\nexports.isOneline = isOneline;","map":{"version":3,"sources":["D:/Github/CUSP_DataBase/CUSP_DB/src/main/mapbox-project/node_modules/expect/build/utils.js"],"names":["Object","defineProperty","exports","value","arrayBufferEquality","emptyObject","typeEquality","subsetEquality","sparseArrayEquality","pathAsArray","partition","iterableEquality","isOneline","isError","getPath","getObjectSubset","_jestGetType","require","_jasmineUtils","global","globalThis","self","window","Function","Symbol","hasPropertyInObject","object","key","shouldTerminate","prototype","hasOwnProperty","call","getPrototypeOf","propertyPath","Array","isArray","length","lastProp","prop","newObject","undefined","hasEndProp","lastTraversedObject","traversedPath","result","slice","unshift","isPrimitive","shift","subset","seenReferences","WeakMap","map","sub","i","Date","isObject","equals","trimmed","set","keys","filter","forEach","has","get","IteratorSymbol","iterator","hasIterator","a","b","aStack","bStack","constructor","push","iterableEqualityWithStack","size","isA","isImmutableUnorderedSet","allFound","aValue","bValue","isEqual","pop","isImmutableUnorderedKeyed","aEntry","bEntry","matchedKey","matchedValue","bIterator","nextB","next","done","isObjectWithKeys","Error","subsetEqualityWithContext","every","delete","ArrayBuffer","dataViewA","DataView","dataViewB","byteLength","getUint8","aKeys","bKeys","items","predicate","item","properties","pattern","RegExp","replace","match","toString","obj","MULTILINE_REGEXP","expected","received","test"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.arrayBufferEquality = void 0;\nexports.emptyObject = emptyObject;\nexports.typeEquality =\n  exports.subsetEquality =\n  exports.sparseArrayEquality =\n  exports.pathAsArray =\n  exports.partition =\n  exports.iterableEquality =\n  exports.isOneline =\n  exports.isError =\n  exports.getPath =\n  exports.getObjectSubset =\n    void 0;\n\nvar _jestGetType = require('jest-get-type');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar global = (function () {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else {\n    return Function('return this')();\n  }\n})();\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\n/**\n * Checks if `hasOwnProperty(object, key)` up the prototype chain, stopping at `Object.prototype`.\n */\nconst hasPropertyInObject = (object, key) => {\n  const shouldTerminate =\n    !object || typeof object !== 'object' || object === Object.prototype;\n\n  if (shouldTerminate) {\n    return false;\n  }\n\n  return (\n    Object.prototype.hasOwnProperty.call(object, key) ||\n    hasPropertyInObject(Object.getPrototypeOf(object), key)\n  );\n};\n\nconst getPath = (object, propertyPath) => {\n  if (!Array.isArray(propertyPath)) {\n    propertyPath = pathAsArray(propertyPath);\n  }\n\n  if (propertyPath.length) {\n    const lastProp = propertyPath.length === 1;\n    const prop = propertyPath[0];\n    const newObject = object[prop];\n\n    if (!lastProp && (newObject === null || newObject === undefined)) {\n      // This is not the last prop in the chain. If we keep recursing it will\n      // hit a `can't access property X of undefined | null`. At this point we\n      // know that the chain has broken and we can return right away.\n      return {\n        hasEndProp: false,\n        lastTraversedObject: object,\n        traversedPath: []\n      };\n    }\n\n    const result = getPath(newObject, propertyPath.slice(1));\n\n    if (result.lastTraversedObject === null) {\n      result.lastTraversedObject = object;\n    }\n\n    result.traversedPath.unshift(prop);\n\n    if (lastProp) {\n      // Does object have the property with an undefined value?\n      // Although primitive values support bracket notation (above)\n      // they would throw TypeError for in operator (below).\n      result.hasEndProp =\n        newObject !== undefined ||\n        (!(0, _jestGetType.isPrimitive)(object) && prop in object);\n\n      if (!result.hasEndProp) {\n        result.traversedPath.shift();\n      }\n    }\n\n    return result;\n  }\n\n  return {\n    lastTraversedObject: null,\n    traversedPath: [],\n    value: object\n  };\n}; // Strip properties from object that are not present in the subset. Useful for\n// printing the diff for toMatchObject() without adding unrelated noise.\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\nexports.getPath = getPath;\n\nconst getObjectSubset = (object, subset, seenReferences = new WeakMap()) => {\n  /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n  if (Array.isArray(object)) {\n    if (Array.isArray(subset) && subset.length === object.length) {\n      // The map method returns correct subclass of subset.\n      return subset.map((sub, i) => getObjectSubset(object[i], sub));\n    }\n  } else if (object instanceof Date) {\n    return object;\n  } else if (isObject(object) && isObject(subset)) {\n    if (\n      (0, _jasmineUtils.equals)(object, subset, [\n        iterableEquality,\n        subsetEquality\n      ])\n    ) {\n      // Avoid unnecessary copy which might return Object instead of subclass.\n      return subset;\n    }\n\n    const trimmed = {};\n    seenReferences.set(object, trimmed);\n    Object.keys(object)\n      .filter(key => hasPropertyInObject(subset, key))\n      .forEach(key => {\n        trimmed[key] = seenReferences.has(object[key])\n          ? seenReferences.get(object[key])\n          : getObjectSubset(object[key], subset[key], seenReferences);\n      });\n\n    if (Object.keys(trimmed).length > 0) {\n      return trimmed;\n    }\n  }\n\n  return object;\n};\n\nexports.getObjectSubset = getObjectSubset;\nconst IteratorSymbol = Symbol.iterator;\n\nconst hasIterator = object => !!(object != null && object[IteratorSymbol]);\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\nconst iterableEquality = (\n  a,\n  b,\n  /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n  aStack = [],\n  bStack = []\n) => {\n  if (\n    typeof a !== 'object' ||\n    typeof b !== 'object' ||\n    Array.isArray(a) ||\n    Array.isArray(b) ||\n    !hasIterator(a) ||\n    !hasIterator(b)\n  ) {\n    return undefined;\n  }\n\n  if (a.constructor !== b.constructor) {\n    return false;\n  }\n\n  let length = aStack.length;\n\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    // circular references at same depth are equal\n    // circular reference is not equal to non-circular one\n    if (aStack[length] === a) {\n      return bStack[length] === b;\n    }\n  }\n\n  aStack.push(a);\n  bStack.push(b);\n\n  const iterableEqualityWithStack = (a, b) =>\n    iterableEquality(a, b, [...aStack], [...bStack]);\n\n  if (a.size !== undefined) {\n    if (a.size !== b.size) {\n      return false;\n    } else if (\n      (0, _jasmineUtils.isA)('Set', a) ||\n      (0, _jasmineUtils.isImmutableUnorderedSet)(a)\n    ) {\n      let allFound = true;\n\n      for (const aValue of a) {\n        if (!b.has(aValue)) {\n          let has = false;\n\n          for (const bValue of b) {\n            const isEqual = (0, _jasmineUtils.equals)(aValue, bValue, [\n              iterableEqualityWithStack\n            ]);\n\n            if (isEqual === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      } // Remove the first value from the stack of traversed values.\n\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    } else if (\n      (0, _jasmineUtils.isA)('Map', a) ||\n      (0, _jasmineUtils.isImmutableUnorderedKeyed)(a)\n    ) {\n      let allFound = true;\n\n      for (const aEntry of a) {\n        if (\n          !b.has(aEntry[0]) ||\n          !(0, _jasmineUtils.equals)(aEntry[1], b.get(aEntry[0]), [\n            iterableEqualityWithStack\n          ])\n        ) {\n          let has = false;\n\n          for (const bEntry of b) {\n            const matchedKey = (0, _jasmineUtils.equals)(aEntry[0], bEntry[0], [\n              iterableEqualityWithStack\n            ]);\n            let matchedValue = false;\n\n            if (matchedKey === true) {\n              matchedValue = (0, _jasmineUtils.equals)(aEntry[1], bEntry[1], [\n                iterableEqualityWithStack\n              ]);\n            }\n\n            if (matchedValue === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      } // Remove the first value from the stack of traversed values.\n\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    }\n  }\n\n  const bIterator = b[IteratorSymbol]();\n\n  for (const aValue of a) {\n    const nextB = bIterator.next();\n\n    if (\n      nextB.done ||\n      !(0, _jasmineUtils.equals)(aValue, nextB.value, [\n        iterableEqualityWithStack\n      ])\n    ) {\n      return false;\n    }\n  }\n\n  if (!bIterator.next().done) {\n    return false;\n  } // Remove the first value from the stack of traversed values.\n\n  aStack.pop();\n  bStack.pop();\n  return true;\n};\n\nexports.iterableEquality = iterableEquality;\n\nconst isObject = a => a !== null && typeof a === 'object';\n\nconst isObjectWithKeys = a =>\n  isObject(a) &&\n  !(a instanceof Error) &&\n  !(a instanceof Array) &&\n  !(a instanceof Date);\n\nconst subsetEquality = (object, subset) => {\n  // subsetEquality needs to keep track of the references\n  // it has already visited to avoid infinite loops in case\n  // there are circular references in the subset passed to it.\n  const subsetEqualityWithContext =\n    (seenReferences = new WeakMap()) =>\n    (object, subset) => {\n      if (!isObjectWithKeys(subset)) {\n        return undefined;\n      }\n\n      return Object.keys(subset).every(key => {\n        if (isObjectWithKeys(subset[key])) {\n          if (seenReferences.has(subset[key])) {\n            return (0, _jasmineUtils.equals)(object[key], subset[key], [\n              iterableEquality\n            ]);\n          }\n\n          seenReferences.set(subset[key], true);\n        }\n\n        const result =\n          object != null &&\n          hasPropertyInObject(object, key) &&\n          (0, _jasmineUtils.equals)(object[key], subset[key], [\n            iterableEquality,\n            subsetEqualityWithContext(seenReferences)\n          ]); // The main goal of using seenReference is to avoid circular node on tree.\n        // It will only happen within a parent and its child, not a node and nodes next to it (same level)\n        // We should keep the reference for a parent and its child only\n        // Thus we should delete the reference immediately so that it doesn't interfere\n        // other nodes within the same level on tree.\n\n        seenReferences.delete(subset[key]);\n        return result;\n      });\n    };\n\n  return subsetEqualityWithContext()(object, subset);\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nexports.subsetEquality = subsetEquality;\n\nconst typeEquality = (a, b) => {\n  if (a == null || b == null || a.constructor === b.constructor) {\n    return undefined;\n  }\n\n  return false;\n};\n\nexports.typeEquality = typeEquality;\n\nconst arrayBufferEquality = (a, b) => {\n  if (!(a instanceof ArrayBuffer) || !(b instanceof ArrayBuffer)) {\n    return undefined;\n  }\n\n  const dataViewA = new DataView(a);\n  const dataViewB = new DataView(b); // Buffers are not equal when they do not have the same byte length\n\n  if (dataViewA.byteLength !== dataViewB.byteLength) {\n    return false;\n  } // Check if every byte value is equal to each other\n\n  for (let i = 0; i < dataViewA.byteLength; i++) {\n    if (dataViewA.getUint8(i) !== dataViewB.getUint8(i)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexports.arrayBufferEquality = arrayBufferEquality;\n\nconst sparseArrayEquality = (a, b) => {\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    return undefined;\n  } // A sparse array [, , 1] will have keys [\"2\"] whereas [undefined, undefined, 1] will have keys [\"0\", \"1\", \"2\"]\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  return (\n    (0, _jasmineUtils.equals)(a, b, [iterableEquality, typeEquality], true) &&\n    (0, _jasmineUtils.equals)(aKeys, bKeys)\n  );\n};\n\nexports.sparseArrayEquality = sparseArrayEquality;\n\nconst partition = (items, predicate) => {\n  const result = [[], []];\n  items.forEach(item => result[predicate(item) ? 0 : 1].push(item));\n  return result;\n};\n\nexports.partition = partition;\n\nconst pathAsArray = propertyPath => {\n  const properties = [];\n\n  if (propertyPath === '') {\n    properties.push('');\n    return properties;\n  } // will match everything that's not a dot or a bracket, and \"\" for consecutive dots.\n\n  const pattern = RegExp('[^.[\\\\]]+|(?=(?:\\\\.)(?:\\\\.|$))', 'g'); // Because the regex won't match a dot in the beginning of the path, if present.\n\n  if (propertyPath[0] === '.') {\n    properties.push('');\n  }\n\n  propertyPath.replace(pattern, match => {\n    properties.push(match);\n    return match;\n  });\n  return properties;\n}; // Copied from https://github.com/graingert/angular.js/blob/a43574052e9775cbc1d7dd8a086752c979b0f020/src/Angular.js#L685-L693\n\nexports.pathAsArray = pathAsArray;\n\nconst isError = value => {\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n      return true;\n\n    default:\n      return value instanceof Error;\n  }\n};\n\nexports.isError = isError;\n\nfunction emptyObject(obj) {\n  return obj && typeof obj === 'object' ? !Object.keys(obj).length : false;\n}\n\nconst MULTILINE_REGEXP = /[\\r\\n]/;\n\nconst isOneline = (expected, received) =>\n  typeof expected === 'string' &&\n  typeof received === 'string' &&\n  (!MULTILINE_REGEXP.test(expected) || !MULTILINE_REGEXP.test(received));\n\nexports.isOneline = isOneline;\n"]},"metadata":{},"sourceType":"script"}