{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as React from 'react';\nimport { LngLatBounds } from 'mapbox-gl';\nimport Supercluster from 'supercluster';\nimport bbox from '@turf/bbox';\nimport { polygon, featureCollection } from '@turf/helpers';\nimport { withMap } from './context';\n\nvar Cluster = function (_super) {\n  __extends(Cluster, _super);\n\n  function Cluster() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      superC: new Supercluster({\n        radius: _this.props.radius,\n        maxZoom: _this.props.maxZoom,\n        minZoom: _this.props.minZoom,\n        extent: _this.props.extent,\n        nodeSize: _this.props.nodeSize,\n        log: _this.props.log\n      }),\n      clusterPoints: []\n    };\n    _this.featureClusterMap = new WeakMap();\n\n    _this.childrenChange = function (newChildren) {\n      var superC = _this.state.superC;\n      _this.featureClusterMap = new WeakMap();\n\n      var features = _this.childrenToFeatures(newChildren);\n\n      superC.load(features);\n    };\n\n    _this.mapChange = function (forceSetState) {\n      if (forceSetState === void 0) {\n        forceSetState = false;\n      }\n\n      var map = _this.props.map;\n      var _a = _this.state,\n          superC = _a.superC,\n          clusterPoints = _a.clusterPoints;\n      var zoom = map.getZoom();\n      var canvas = map.getCanvas();\n      var w = canvas.width;\n      var h = canvas.height;\n      var upLeft = map.unproject([0, 0]).toArray();\n      var upRight = map.unproject([w, 0]).toArray();\n      var downRight = map.unproject([w, h]).toArray();\n      var downLeft = map.unproject([0, h]).toArray();\n      var newPoints = superC.getClusters(bbox(polygon([[upLeft, upRight, downRight, downLeft, upLeft]])), Math.round(zoom));\n\n      if (newPoints.length !== clusterPoints.length || forceSetState) {\n        _this.setState({\n          clusterPoints: newPoints\n        });\n      }\n    };\n\n    _this.childrenToFeatures = function (children) {\n      return children.map(function (child) {\n        var feature = _this.feature(child && child.props.coordinates);\n\n        _this.featureClusterMap.set(feature, child);\n\n        return feature;\n      });\n    };\n\n    _this.getLeaves = function (feature, limit, offset) {\n      var superC = _this.state.superC;\n      return superC.getLeaves(feature.properties && feature.properties.cluster_id, limit || Infinity, offset).map(function (leave) {\n        return _this.featureClusterMap.get(leave);\n      });\n    };\n\n    _this.zoomToClusterBounds = function (event) {\n      var markers = Array.prototype.slice.call(event.currentTarget.children);\n\n      var marker = _this.findMarkerElement(event.currentTarget, event.target);\n\n      var index = markers.indexOf(marker);\n      var cluster = _this.state.clusterPoints[index];\n\n      if (!cluster.properties || !cluster.properties.cluster_id) {\n        return;\n      }\n\n      var children = _this.state.superC.getLeaves(cluster.properties && cluster.properties.cluster_id, Infinity);\n\n      var childrenBbox = bbox(featureCollection(children));\n\n      _this.props.map.fitBounds(LngLatBounds.convert(childrenBbox), {\n        padding: _this.props.zoomOnClickPadding\n      });\n    };\n\n    return _this;\n  }\n\n  Cluster.prototype.componentDidMount = function () {\n    var _a = this.props,\n        children = _a.children,\n        map = _a.map;\n\n    if (children) {\n      this.childrenChange(children);\n    }\n\n    map.on('move', this.mapChange);\n    map.on('zoom', this.mapChange);\n    this.mapChange();\n  };\n\n  Cluster.prototype.componentWillUnmount = function () {\n    var map = this.props.map;\n    map.off('move', this.mapChange);\n    map.off('zoom', this.mapChange);\n  };\n\n  Cluster.prototype.componentDidUpdate = function (prevProps) {\n    var children = prevProps.children;\n\n    if (children !== this.props.children && this.props.children) {\n      this.childrenChange(this.props.children);\n      this.mapChange(true);\n    }\n  };\n\n  Cluster.prototype.feature = function (coordinates) {\n    return {\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: coordinates\n      },\n      properties: {}\n    };\n  };\n\n  Cluster.prototype.findMarkerElement = function (target, element) {\n    if (element.parentElement === target) {\n      return element;\n    }\n\n    return this.findMarkerElement(target, element.parentElement);\n  };\n\n  Cluster.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        ClusterMarkerFactory = _a.ClusterMarkerFactory,\n        style = _a.style,\n        className = _a.className,\n        tabIndex = _a.tabIndex;\n    var clusterPoints = this.state.clusterPoints;\n    return React.createElement(\"div\", {\n      style: style,\n      className: className,\n      tabIndex: tabIndex,\n      onClick: this.props.zoomOnClick ? this.zoomToClusterBounds : undefined\n    }, clusterPoints.map(function (feature) {\n      if (feature.properties && feature.properties.cluster) {\n        return ClusterMarkerFactory(feature.geometry.coordinates, feature.properties.point_count, _this.getLeaves.bind(_this, feature));\n      }\n\n      return _this.featureClusterMap.get(feature);\n    }));\n  };\n\n  Cluster.defaultProps = {\n    radius: 60,\n    minZoom: 0,\n    maxZoom: 16,\n    extent: 512,\n    nodeSize: 64,\n    log: false,\n    zoomOnClick: false,\n    zoomOnClickPadding: 20\n  };\n  return Cluster;\n}(React.Component);\n\nexport { Cluster };\nexport default withMap(Cluster);","map":{"version":3,"mappings":"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","names":["React","LngLatBounds","Supercluster","bbox","polygon","featureCollection","withMap","__extends","_this","superC","radius","props","maxZoom","minZoom","extent","nodeSize","log","clusterPoints","WeakMap","newChildren","featureClusterMap","features","childrenToFeatures","load","forceSetState","zoom","map","getZoom","canvas","getCanvas","w","width","h","height","upLeft","unproject","toArray","upRight","downRight","downLeft","newPoints","getClusters","Math","round","length","setState","children","feature","child","coordinates","set","limit","offset","getLeaves","properties","cluster_id","Infinity","leave","get","event","markers","Array","prototype","slice","call","currentTarget","marker","findMarkerElement","target","index","indexOf","cluster","state","childrenBbox","fitBounds","convert","padding","zoomOnClickPadding","Cluster","childrenChange","on","mapChange","off","prevProps","type","geometry","element","parentElement","ClusterMarkerFactory","style","className","tabIndex","onClick","zoomOnClick","zoomToClusterBounds","undefined","point_count","bind","Component"],"sources":["D:\\Github\\CUSP_DataBase\\CUSP_DB\\src\\main\\mapbox-project\\node_modules\\react-mapbox-gl\\src\\cluster.tsx"],"sourcesContent":["import * as React from 'react';\nimport { LngLatBounds, Map } from 'mapbox-gl';\nimport { Props as MarkerProps } from './marker';\nimport Supercluster from 'supercluster';\nimport * as GeoJSON from 'geojson';\nimport bbox from '@turf/bbox';\nimport { polygon, featureCollection } from '@turf/helpers';\nimport { withMap } from './context';\n\nexport interface Props {\n  ClusterMarkerFactory(\n    coordinates: GeoJSON.Position,\n    pointCount: number,\n    getLeaves: (\n      limit?: number,\n      offset?: number\n    ) => Array<React.ReactElement<MarkerProps> | undefined>\n  ): React.ReactElement<MarkerProps>;\n  radius?: number;\n  maxZoom?: number;\n  minZoom?: number;\n  extent?: number;\n  nodeSize?: number;\n  log?: boolean;\n  zoomOnClick?: boolean;\n  zoomOnClickPadding?: number;\n  children?: Array<React.ReactElement<MarkerProps>>;\n  style?: React.CSSProperties;\n  className?: string;\n  tabIndex?: number;\n  map: Map;\n}\n\nexport interface State {\n  superC: Supercluster;\n  clusterPoints: Array<GeoJSON.Feature<GeoJSON.Point>>;\n}\n\nexport class Cluster extends React.Component<Props, State> {\n  public static defaultProps = {\n    radius: 60,\n    minZoom: 0,\n    maxZoom: 16,\n    extent: 512,\n    nodeSize: 64,\n    log: false,\n    zoomOnClick: false,\n    zoomOnClickPadding: 20\n  };\n\n  public state: State = {\n    superC: new Supercluster({\n      radius: this.props.radius,\n      maxZoom: this.props.maxZoom,\n      minZoom: this.props.minZoom,\n      extent: this.props.extent,\n      nodeSize: this.props.nodeSize,\n      log: this.props.log\n    }),\n    clusterPoints: []\n  };\n\n  private featureClusterMap = new WeakMap<\n    GeoJSON.Feature,\n    React.ReactElement<MarkerProps>\n  >();\n\n  public componentDidMount() {\n    const { children, map } = this.props;\n\n    if (children) {\n      this.childrenChange(children as Array<React.ReactElement<MarkerProps>>);\n    }\n\n    map.on('move', this.mapChange);\n    map.on('zoom', this.mapChange);\n    this.mapChange();\n  }\n\n  public componentWillUnmount() {\n    const { map } = this.props;\n\n    map.off('move', this.mapChange);\n    map.off('zoom', this.mapChange);\n  }\n\n  public componentDidUpdate(prevProps: Props) {\n    const { children } = prevProps;\n\n    if (children !== this.props.children && this.props.children) {\n      this.childrenChange(this.props.children);\n      this.mapChange(true);\n    }\n  }\n\n  private childrenChange = (\n    newChildren: Array<React.ReactElement<MarkerProps>>\n  ) => {\n    const { superC } = this.state;\n    this.featureClusterMap = new WeakMap<\n      GeoJSON.Feature,\n      React.ReactElement<MarkerProps>\n    >();\n    const features = this.childrenToFeatures(newChildren);\n    superC.load(features);\n  };\n\n  private mapChange = (forceSetState: boolean = false) => {\n    const { map } = this.props;\n    const { superC, clusterPoints } = this.state;\n\n    const zoom = map.getZoom();\n    const canvas = map.getCanvas();\n    const w = canvas.width;\n    const h = canvas.height;\n    const upLeft = map.unproject([0, 0]).toArray();\n    const upRight = map.unproject([w, 0]).toArray();\n    const downRight = map.unproject([w, h]).toArray();\n    const downLeft = map.unproject([0, h]).toArray();\n    const newPoints = superC.getClusters(\n      bbox(polygon([[upLeft, upRight, downRight, downLeft, upLeft]])),\n      Math.round(zoom)\n    );\n    if (newPoints.length !== clusterPoints.length || forceSetState) {\n      this.setState({ clusterPoints: newPoints });\n    }\n  };\n\n  private feature(coordinates: GeoJSON.Position) {\n    return {\n      type: 'Feature' as 'Feature',\n      geometry: {\n        type: 'Point' as 'Point',\n        coordinates\n      },\n      properties: {}\n    };\n  }\n\n  private childrenToFeatures = (\n    children: Array<React.ReactElement<MarkerProps>>\n  ) =>\n    children.map(child => {\n      const feature = this.feature(child && child.props.coordinates);\n      this.featureClusterMap.set(feature, child);\n      return feature;\n    });\n\n  private getLeaves = (\n    feature: GeoJSON.Feature,\n    limit?: number,\n    offset?: number\n  ) => {\n    const { superC } = this.state;\n    return superC\n      .getLeaves(\n        feature.properties && feature.properties.cluster_id,\n        limit || Infinity,\n        offset\n      )\n      .map((leave: GeoJSON.Feature) => this.featureClusterMap.get(leave));\n  };\n\n  public zoomToClusterBounds = (event: React.MouseEvent<HTMLElement>) => {\n    const markers = Array.prototype.slice.call(event.currentTarget.children);\n    const marker = this.findMarkerElement(\n      event.currentTarget,\n      event.target as HTMLElement\n    );\n    const index = markers.indexOf(marker);\n    const cluster = this.state.clusterPoints[index] as GeoJSON.Feature;\n    if (!cluster.properties || !cluster.properties.cluster_id) {\n      return;\n    }\n    const children = this.state.superC.getLeaves(\n      cluster.properties && cluster.properties.cluster_id,\n      Infinity\n    );\n    const childrenBbox = bbox(featureCollection(children));\n    // https://github.com/mapbox/mapbox-gl-js/issues/5249\n    // tslint:disable-next-line:no-any\n    this.props.map.fitBounds(LngLatBounds.convert(childrenBbox as any), {\n      padding: this.props.zoomOnClickPadding!\n    });\n  };\n\n  private findMarkerElement(\n    target: HTMLElement,\n    element: HTMLElement\n  ): HTMLElement {\n    if (element.parentElement === target) {\n      return element;\n    }\n    return this.findMarkerElement(target, element.parentElement!);\n  }\n\n  public render() {\n    const { ClusterMarkerFactory, style, className, tabIndex } = this.props;\n    const { clusterPoints } = this.state;\n\n    return (\n      <div\n        style={style}\n        className={className}\n        tabIndex={tabIndex}\n        onClick={this.props.zoomOnClick ? this.zoomToClusterBounds : undefined}\n      >\n        {clusterPoints.map((feature: GeoJSON.Feature<GeoJSON.Point>) => {\n          if (feature.properties && feature.properties.cluster) {\n            return ClusterMarkerFactory(\n              feature.geometry.coordinates,\n              feature.properties.point_count,\n              this.getLeaves.bind(this, feature)\n            );\n          }\n          return this.featureClusterMap.get(feature);\n        })}\n      </div>\n    );\n  }\n}\n\nexport default withMap(Cluster);\n"]},"metadata":{},"sourceType":"module"}