{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\n\nvar isEqual = require('deep-equal');\n\nimport diff from './util/diff';\nvar eventToHandler = {\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchcancel: 'onTouchCancel',\n  mousemove: 'onMouseMove',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  click: 'onClick'\n};\n\nvar Layer = function (_super) {\n  __extends(Layer, _super);\n\n  function Layer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.source = __assign({\n      type: 'geojson'\n    }, _this.props.geoJSONSourceOptions, {\n      data: {\n        type: 'FeatureCollection',\n        features: []\n      }\n    });\n\n    _this.geometry = function (coordinates) {\n      switch (_this.props.type) {\n        case 'symbol':\n        case 'circle':\n          return {\n            type: 'Point',\n            coordinates: coordinates\n          };\n\n        case 'fill':\n          if (Array.isArray(coordinates[0][0][0])) {\n            return {\n              type: 'MultiPolygon',\n              coordinates: coordinates\n            };\n          }\n\n          return {\n            type: 'Polygon',\n            coordinates: coordinates\n          };\n\n        case 'line':\n          return {\n            type: 'LineString',\n            coordinates: coordinates\n          };\n\n        default:\n          return {\n            type: 'Point',\n            coordinates: coordinates\n          };\n      }\n    };\n\n    _this.makeFeature = function (props, id) {\n      return {\n        type: 'Feature',\n        geometry: _this.geometry(props.coordinates),\n        properties: __assign({}, props.properties, {\n          id: id\n        })\n      };\n    };\n\n    _this.initialize = function () {\n      var _a = _this.props,\n          type = _a.type,\n          layout = _a.layout,\n          paint = _a.paint,\n          sourceId = _a.sourceId,\n          before = _a.before,\n          images = _a.images,\n          id = _a.id,\n          metadata = _a.metadata,\n          sourceLayer = _a.sourceLayer,\n          minZoom = _a.minZoom,\n          maxZoom = _a.maxZoom,\n          filter = _a.filter;\n      var map = _this.props.map;\n      var layer = {\n        id: id,\n        source: sourceId || id,\n        type: type,\n        layout: layout,\n        paint: paint,\n        metadata: metadata\n      };\n\n      if (sourceLayer) {\n        layer['source-layer'] = sourceLayer;\n      }\n\n      if (minZoom) {\n        layer.minzoom = minZoom;\n      }\n\n      if (maxZoom) {\n        layer.maxzoom = maxZoom;\n      }\n\n      if (filter) {\n        layer.filter = filter;\n      }\n\n      if (images) {\n        var normalizedImages = !Array.isArray(images[0]) ? [images] : images;\n        normalizedImages.filter(function (image) {\n          return !map.hasImage(image[0]);\n        }).forEach(function (image) {\n          map.addImage(image[0], image[1], image[2]);\n        });\n      }\n\n      if (!sourceId && !map.getSource(id)) {\n        map.addSource(id, _this.source);\n      }\n\n      if (!map.getLayer(id)) {\n        map.addLayer(layer, before);\n      }\n\n      Object.entries(eventToHandler).forEach(function (_a) {\n        var event = _a[0],\n            propName = _a[1];\n        var handler = _this.props[propName];\n\n        if (handler) {\n          map.on(event, id, handler);\n        }\n      });\n    };\n\n    _this.onStyleDataChange = function () {\n      if (!_this.props.map.getLayer(_this.props.id)) {\n        _this.initialize();\n\n        _this.forceUpdate();\n      }\n    };\n\n    _this.getChildren = function () {\n      var children = _this.props.children;\n\n      if (!children) {\n        return [];\n      }\n\n      if (Array.isArray(children)) {\n        return children.reduce(function (arr, next) {\n          return arr.concat(next);\n        }, []);\n      }\n\n      return [children];\n    };\n\n    return _this;\n  }\n\n  Layer.prototype.componentDidMount = function () {\n    var map = this.props.map;\n    this.initialize();\n    map.on('styledata', this.onStyleDataChange);\n  };\n\n  Layer.prototype.componentWillUnmount = function () {\n    var _this = this;\n\n    var map = this.props.map;\n    var _a = this.props,\n        images = _a.images,\n        id = _a.id;\n\n    if (!map || !map.getStyle()) {\n      return;\n    }\n\n    map.off('styledata', this.onStyleDataChange);\n    Object.entries(eventToHandler).forEach(function (_a) {\n      var event = _a[0],\n          propName = _a[1];\n      var handler = _this.props[propName];\n\n      if (handler) {\n        map.off(event, id, handler);\n      }\n    });\n\n    if (map.getLayer(id)) {\n      map.removeLayer(id);\n    }\n\n    if (!this.props.sourceId) {\n      map.removeSource(id);\n    }\n\n    if (images) {\n      var normalizedImages = !Array.isArray(images[0]) ? [images] : images;\n      normalizedImages.map(function (_a) {\n        var key = _a[0],\n            rest = _a.slice(1);\n\n        return key;\n      }).forEach(map.removeImage.bind(map));\n    }\n  };\n\n  Layer.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    var paint = prevProps.paint,\n        layout = prevProps.layout,\n        before = prevProps.before,\n        filter = prevProps.filter,\n        id = prevProps.id,\n        minZoom = prevProps.minZoom,\n        maxZoom = prevProps.maxZoom,\n        map = prevProps.map;\n\n    if (!isEqual(this.props.paint, paint)) {\n      var paintDiff_1 = diff(paint, this.props.paint);\n      Object.keys(paintDiff_1).forEach(function (key) {\n        map.setPaintProperty(id, key, paintDiff_1[key]);\n      });\n    }\n\n    if (!isEqual(this.props.layout, layout)) {\n      var layoutDiff_1 = diff(layout, this.props.layout);\n      Object.keys(layoutDiff_1).forEach(function (key) {\n        map.setLayoutProperty(id, key, layoutDiff_1[key]);\n      });\n    }\n\n    if (!isEqual(this.props.filter, filter)) {\n      map.setFilter(id, this.props.filter);\n    }\n\n    if (before !== this.props.before) {\n      map.moveLayer(id, this.props.before);\n    }\n\n    if (minZoom !== this.props.minZoom || maxZoom !== this.props.maxZoom) {\n      map.setLayerZoomRange(id, this.props.minZoom, this.props.maxZoom);\n    }\n\n    Object.entries(eventToHandler).forEach(function (_a) {\n      var event = _a[0],\n          propName = _a[1];\n      var oldHandler = prevProps[propName];\n      var newHandler = _this.props[propName];\n\n      if (oldHandler !== newHandler) {\n        if (oldHandler) {\n          map.off(event, id, oldHandler);\n        }\n\n        if (newHandler) {\n          map.on(event, id, newHandler);\n        }\n      }\n    });\n  };\n\n  Layer.prototype.render = function () {\n    var _this = this;\n\n    var map = this.props.map;\n    var _a = this.props,\n        sourceId = _a.sourceId,\n        draggedChildren = _a.draggedChildren;\n    var children = this.getChildren();\n\n    if (draggedChildren) {\n      var draggableChildrenIds_1 = draggedChildren.map(function (child) {\n        return child.key;\n      });\n      children = children.map(function (child) {\n        var indexChildren = draggableChildrenIds_1.indexOf(child.key);\n\n        if (indexChildren !== -1) {\n          return draggedChildren[indexChildren];\n        }\n\n        return child;\n      });\n    }\n\n    var features = children.map(function (_a, id) {\n      var props = _a.props;\n      return _this.makeFeature(props, id);\n    }).filter(Boolean);\n    var source = map.getSource(sourceId || this.props.id);\n\n    if (source && !sourceId && source.setData) {\n      source.setData({\n        type: 'FeatureCollection',\n        features: features\n      });\n    }\n\n    return null;\n  };\n\n  Layer.defaultProps = {\n    type: 'symbol',\n    layout: {},\n    paint: {}\n  };\n  return Layer;\n}(React.Component);\n\nexport default Layer;","map":{"version":3,"mappings":"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","names":["React","isEqual","require","diff","eventToHandler","touchstart","touchend","touchcancel","mousemove","mouseenter","mouseleave","mousedown","mouseup","click","__extends","_this","__assign","type","props","geoJSONSourceOptions","data","features","coordinates","Array","isArray","id","geometry","properties","layout","paint","sourceId","before","images","metadata","sourceLayer","minZoom","maxZoom","filter","layer","source","minzoom","maxzoom","normalizedImages","map","hasImage","image","forEach","addImage","getSource","addSource","getLayer","addLayer","Object","entries","_a","event","propName","handler","on","initialize","forceUpdate","children","reduce","arr","next","concat","Layer","onStyleDataChange","getStyle","off","removeLayer","removeSource","key","rest","removeImage","bind","prevProps","paintDiff_1","keys","setPaintProperty","layoutDiff_1","setLayoutProperty","setFilter","moveLayer","setLayerZoomRange","oldHandler","newHandler","draggedChildren","getChildren","draggableChildrenIds_1","indexChildren","indexOf","child","makeFeature","Boolean","setData","Component"],"sources":["D:\\Github\\CUSP_DataBase\\CUSP_DB\\src\\main\\mapbox-project\\node_modules\\react-mapbox-gl\\src\\layer.ts"],"sourcesContent":["import * as React from 'react';\nimport * as MapboxGL from 'mapbox-gl';\nconst isEqual = require('deep-equal'); //tslint:disable-line\nimport diff from './util/diff';\nimport { Props as FeatureProps } from './feature';\n\nexport type Paint =\n  | MapboxGL.BackgroundPaint\n  | MapboxGL.FillPaint\n  | MapboxGL.FillExtrusionPaint\n  | MapboxGL.SymbolPaint\n  | MapboxGL.LinePaint\n  | MapboxGL.RasterPaint\n  | MapboxGL.CirclePaint;\n\nexport type Layout =\n  | MapboxGL.BackgroundLayout\n  | MapboxGL.FillLayout\n  | MapboxGL.FillExtrusionLayout\n  | MapboxGL.LineLayout\n  | MapboxGL.SymbolLayout\n  | MapboxGL.RasterLayout\n  | MapboxGL.CircleLayout;\n\nexport interface ImageOptions {\n  width?: number;\n  height?: number;\n  pixelRatio?: number;\n}\nexport type ImageDefinition = [string, HTMLImageElement];\nexport type ImageDefinitionWithOptions = [\n  string,\n  HTMLImageElement,\n  ImageOptions\n];\n\n// tslint:disable-next-line:no-any\nexport type MouseEvent = (evt: any) => any;\n\nexport interface LayerEvents {\n  onMouseMove?: MouseEvent;\n  onMouseEnter?: MouseEvent;\n  onMouseLeave?: MouseEvent;\n  onMouseDown?: MouseEvent;\n  onMouseUp?: MouseEvent;\n  onClick?: MouseEvent;\n  onTouchStart?: MouseEvent;\n  onTouchEnd?: MouseEvent;\n  onTouchCancel?: MouseEvent;\n}\n\nexport interface LayerCommonProps {\n  type?:\n    | 'symbol'\n    | 'line'\n    | 'fill'\n    | 'circle'\n    | 'raster'\n    | 'fill-extrusion'\n    | 'background'\n    | 'heatmap';\n  sourceId?: string;\n  images?:\n    | ImageDefinition\n    | ImageDefinition[]\n    | ImageDefinitionWithOptions\n    | ImageDefinitionWithOptions[];\n  before?: string;\n  paint?: Paint;\n  layout?: Layout;\n  // tslint:disable-next-line:no-any\n  metadata?: any;\n  sourceLayer?: string;\n  minZoom?: number;\n  maxZoom?: number;\n  geoJSONSourceOptions?: MapboxGL.GeoJSONSourceOptions;\n  // tslint:disable-next-line:no-any\n  filter?: any[];\n  children?: JSX.Element | JSX.Element[];\n}\n\nexport interface OwnProps {\n  id: string;\n  draggedChildren?: JSX.Element[];\n  map: MapboxGL.Map;\n}\n\nexport type Props = LayerCommonProps & LayerEvents & OwnProps;\n\ntype EventToHandlersType = {\n  [key in keyof MapboxGL.MapLayerEventType]?: keyof LayerEvents\n};\n\nconst eventToHandler: EventToHandlersType = {\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchcancel: 'onTouchCancel',\n  mousemove: 'onMouseMove',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  click: 'onClick'\n};\n\nexport default class Layer extends React.Component<Props> {\n  public static defaultProps = {\n    type: 'symbol' as 'symbol',\n    layout: {},\n    paint: {}\n  };\n\n  private source: MapboxGL.GeoJSONSourceRaw = {\n    type: 'geojson',\n    ...this.props.geoJSONSourceOptions,\n    data: {\n      type: 'FeatureCollection',\n      features: []\n    }\n  };\n\n  // tslint:disable-next-line:no-any\n  private geometry = (coordinates: any): GeoJSON.Geometry => {\n    switch (this.props.type) {\n      case 'symbol':\n      case 'circle':\n        return {\n          type: 'Point',\n          coordinates\n        };\n\n      case 'fill':\n        if (Array.isArray(coordinates[0][0][0])) {\n          return {\n            type: 'MultiPolygon',\n            coordinates\n          };\n        }\n        return {\n          type: 'Polygon',\n          coordinates\n        };\n\n      case 'line':\n        return {\n          type: 'LineString',\n          coordinates\n        };\n\n      default:\n        return {\n          type: 'Point',\n          coordinates\n        };\n    }\n  };\n\n  private makeFeature = (\n    props: FeatureProps,\n    id: number\n  ): GeoJSON.Feature<GeoJSON.Geometry, GeoJSON.GeoJsonProperties> => ({\n    type: 'Feature',\n    geometry: this.geometry(props.coordinates),\n    properties: { ...props.properties, id }\n  });\n\n  private initialize = () => {\n    const {\n      type,\n      layout,\n      paint,\n      sourceId,\n      before,\n      images,\n      id,\n      metadata,\n      sourceLayer,\n      minZoom,\n      maxZoom,\n      filter\n    } = this.props;\n    const { map } = this.props;\n\n    const layer: MapboxGL.Layer = {\n      id,\n      source: sourceId || id,\n      // TODO: Fix mapbox-gl types\n      // tslint:disable-next-line:no-any\n      type: type as any,\n      layout,\n      // TODO: Fix mapbox-gl types\n      // tslint:disable-next-line:no-any\n      paint: paint as any,\n      metadata\n    };\n\n    if (sourceLayer) {\n      layer['source-layer'] = sourceLayer;\n    }\n\n    if (minZoom) {\n      layer.minzoom = minZoom;\n    }\n\n    if (maxZoom) {\n      layer.maxzoom = maxZoom;\n    }\n\n    if (filter) {\n      layer.filter = filter;\n    }\n\n    if (images) {\n      const normalizedImages = !Array.isArray(images[0]) ? [images] : images;\n      (normalizedImages as ImageDefinitionWithOptions[])\n        .filter(image => !map.hasImage(image[0]))\n        .forEach(image => {\n          map.addImage(image[0], image[1], image[2]);\n        });\n    }\n\n    if (!sourceId && !map.getSource(id)) {\n      map.addSource(id, this.source);\n    }\n\n    if (!map.getLayer(id)) {\n      map.addLayer(layer, before);\n    }\n\n    (Object.entries(eventToHandler) as Array<\n      [keyof EventToHandlersType, keyof LayerEvents]\n    >).forEach(([event, propName]) => {\n      const handler = this.props[propName];\n      if (handler) {\n        map.on(event, id, handler);\n      }\n    });\n  };\n\n  private onStyleDataChange = () => {\n    // if the style of the map has been updated and we don't have layer anymore,\n    // add it back to the map and force re-rendering to redraw it\n    if (!this.props.map.getLayer(this.props.id)) {\n      this.initialize();\n      this.forceUpdate();\n    }\n  };\n\n  public componentDidMount() {\n    const { map } = this.props;\n\n    this.initialize();\n\n    map.on('styledata', this.onStyleDataChange);\n  }\n\n  public componentWillUnmount() {\n    const { map } = this.props;\n    const { images, id } = this.props;\n\n    if (!map || !map.getStyle()) {\n      return;\n    }\n\n    map.off('styledata', this.onStyleDataChange);\n\n    (Object.entries(eventToHandler) as Array<\n      [keyof EventToHandlersType, keyof LayerEvents]\n    >).forEach(([event, propName]) => {\n      const handler = this.props[propName];\n      if (handler) {\n        map.off(event, id, handler);\n      }\n    });\n\n    if (map.getLayer(id)) {\n      map.removeLayer(id);\n    }\n    // if pointing to an existing source, don't remove\n    // as other layers may be dependent upon it\n    if (!this.props.sourceId) {\n      map.removeSource(id);\n    }\n\n    if (images) {\n      const normalizedImages = !Array.isArray(images[0]) ? [images] : images;\n      (normalizedImages as ImageDefinitionWithOptions[])\n        .map(([key, ...rest]) => key)\n        .forEach(map.removeImage.bind(map));\n    }\n  }\n\n  public componentDidUpdate(prevProps: Props) {\n    const {\n      paint,\n      layout,\n      before,\n      filter,\n      id,\n      minZoom,\n      maxZoom,\n      map\n    } = prevProps;\n\n    if (!isEqual(this.props.paint, paint)) {\n      const paintDiff = diff(paint, this.props.paint);\n\n      Object.keys(paintDiff).forEach(key => {\n        map.setPaintProperty(id, key, paintDiff[key]);\n      });\n    }\n\n    if (!isEqual(this.props.layout, layout)) {\n      const layoutDiff = diff(layout, this.props.layout);\n\n      Object.keys(layoutDiff).forEach(key => {\n        map.setLayoutProperty(id, key, layoutDiff[key]);\n      });\n    }\n\n    if (!isEqual(this.props.filter, filter)) {\n      map.setFilter(id, this.props.filter);\n    }\n\n    if (before !== this.props.before) {\n      map.moveLayer(id, this.props.before);\n    }\n\n    if (minZoom !== this.props.minZoom || maxZoom !== this.props.maxZoom) {\n      // TODO: Fix when PR https://github.com/DefinitelyTyped/DefinitelyTyped/pull/22036 is merged\n      map.setLayerZoomRange(id, this.props.minZoom!, this.props.maxZoom!);\n    }\n\n    (Object.entries(eventToHandler) as Array<\n      [keyof EventToHandlersType, keyof LayerEvents]\n    >).forEach(([event, propName]) => {\n      const oldHandler = prevProps[propName];\n      const newHandler = this.props[propName];\n\n      if (oldHandler !== newHandler) {\n        if (oldHandler) {\n          map.off(event, id, oldHandler);\n        }\n\n        if (newHandler) {\n          map.on(event, id, newHandler);\n        }\n      }\n    });\n  }\n\n  public getChildren = () => {\n    const { children } = this.props;\n\n    if (!children) {\n      return [];\n    }\n\n    if (Array.isArray(children)) {\n      return (children as JSX.Element[][]).reduce(\n        (arr, next) => arr.concat(next),\n        [] as JSX.Element[]\n      );\n    }\n\n    return [children] as JSX.Element[];\n  };\n\n  public render() {\n    const { map } = this.props;\n    const { sourceId, draggedChildren } = this.props;\n    let children = this.getChildren();\n\n    if (draggedChildren) {\n      const draggableChildrenIds = draggedChildren.map(child => child.key);\n      children = children.map(child => {\n        const indexChildren = draggableChildrenIds.indexOf(child.key);\n        if (indexChildren !== -1) {\n          return draggedChildren[indexChildren];\n        }\n        return child;\n      });\n    }\n\n    const features = (children! as Array<React.ReactElement<FeatureProps>>)\n      .map(({ props }, id) => this.makeFeature(props, id))\n      .filter(Boolean);\n\n    const source = map.getSource(\n      sourceId || this.props.id\n    ) as MapboxGL.GeoJSONSource;\n\n    if (source && !sourceId && source.setData) {\n      source.setData({\n        type: 'FeatureCollection',\n        features: features as GeoJSON.Feature[]\n      });\n    }\n\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}