{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) => line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\n\nconst printDiffLine = (line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) => line.length !== 0 ? color(indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)) : indicator !== ' ' ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder) : '';\n\nconst printDeleteLine = (line, isFirstOrLast, _ref) => {\n  let {\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  } = _ref;\n  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n};\n\nconst printInsertLine = (line, isFirstOrLast, _ref2) => {\n  let {\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  } = _ref2;\n  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n};\n\nconst printCommonLine = (line, isFirstOrLast, _ref3) => {\n  let {\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  } = _ref3;\n  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);\n}; // In GNU diff format, indexes are one-based instead of zero-based.\n\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, _ref4) => {\n  let {\n    patchColor\n  } = _ref4;\n  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);\n}; // jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\n\n\nconst joinAlignedDiffsNoExpand = (diffs, options) => {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines; // First pass: count output lines and see if it has patches.\n\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n\n  while (i !== iLength) {\n    const iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at start\n        if (i > nContextLines) {\n          jLength -= i - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        // at end\n        const n = i - iStart;\n\n        if (n > nContextLines) {\n          jLength -= n - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        // between changes\n        const n = i - iStart;\n\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2; // subtract excess common lines\n\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1; // add patch lines\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1; // add patch line\n  }\n\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0; // index of placeholder line for current patch mark\n\n  if (hasPatch) {\n    lines.push(''); // placeholder line for first patch mark\n  } // Indexes of expected or received lines in current patch:\n\n\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n\n  const pushCommonLine = line => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  };\n\n  const pushDeleteLine = line => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  };\n\n  const pushInsertLine = line => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  }; // Second pass: push lines with diff formatting (and patch marks, if needed).\n\n\n  i = 0;\n\n  while (i !== iLength) {\n    let iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at beginning\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        // at end\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        // between changes\n        const nCommon = i - iStart;\n\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n\n          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n          jPatchMark = lines.length;\n          lines.push(''); // placeholder line for next patch mark\n\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n\n  return lines.join('\\n');\n}; // jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\n\n\nexports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;\n\nconst joinAlignedDiffsExpand = (diffs, options) => diffs.map((diff, i, diffs) => {\n  const line = diff[1];\n  const isFirstOrLast = i === 0 || i === diffs.length - 1;\n\n  switch (diff[0]) {\n    case _cleanupSemantic.DIFF_DELETE:\n      return printDeleteLine(line, isFirstOrLast, options);\n\n    case _cleanupSemantic.DIFF_INSERT:\n      return printInsertLine(line, isFirstOrLast, options);\n\n    default:\n      return printCommonLine(line, isFirstOrLast, options);\n  }\n}).join('\\n');\n\nexports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;","map":{"version":3,"sources":["D:/Github/CUSP_DataBase/CUSP_DB/src/main/mapbox-project/node_modules/jest-diff/build/joinAlignedDiffs.js"],"names":["Object","defineProperty","exports","value","joinAlignedDiffsNoExpand","joinAlignedDiffsExpand","_cleanupSemantic","require","formatTrailingSpaces","line","trailingSpaceFormatter","replace","match","printDiffLine","isFirstOrLast","color","indicator","emptyFirstOrLastLinePlaceholder","length","printDeleteLine","aColor","aIndicator","changeLineTrailingSpaceColor","printInsertLine","bColor","bIndicator","printCommonLine","commonColor","commonIndicator","commonLineTrailingSpaceColor","createPatchMark","aStart","aEnd","bStart","bEnd","patchColor","diffs","options","iLength","nContextLines","contextLines","nContextLines2","jLength","hasExcessAtStartOrEnd","nExcessesBetweenChanges","i","iStart","DIFF_EQUAL","n","hasPatch","jLast","lines","jPatchMark","push","pushCommonLine","j","pushDeleteLine","pushInsertLine","iCommon","iEnd","nCommon","nOmit","DIFF_DELETE","DIFF_INSERT","join","map","diff"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.joinAlignedDiffsNoExpand = exports.joinAlignedDiffsExpand = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst formatTrailingSpaces = (line, trailingSpaceFormatter) =>\n  line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\n\nconst printDiffLine = (\n  line,\n  isFirstOrLast,\n  color,\n  indicator,\n  trailingSpaceFormatter,\n  emptyFirstOrLastLinePlaceholder\n) =>\n  line.length !== 0\n    ? color(\n        indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)\n      )\n    : indicator !== ' '\n    ? color(indicator)\n    : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0\n    ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder)\n    : '';\n\nconst printDeleteLine = (\n  line,\n  isFirstOrLast,\n  {\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\nconst printInsertLine = (\n  line,\n  isFirstOrLast,\n  {\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  );\n\nconst printCommonLine = (\n  line,\n  isFirstOrLast,\n  {\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  }\n) =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder\n  ); // In GNU diff format, indexes are one-based instead of zero-based.\n\nconst createPatchMark = (aStart, aEnd, bStart, bEnd, {patchColor}) =>\n  patchColor(\n    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`\n  ); // jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\n\nconst joinAlignedDiffsNoExpand = (diffs, options) => {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines; // First pass: count output lines and see if it has patches.\n\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n\n  while (i !== iLength) {\n    const iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at start\n        if (i > nContextLines) {\n          jLength -= i - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        // at end\n        const n = i - iStart;\n\n        if (n > nContextLines) {\n          jLength -= n - nContextLines; // subtract excess common lines\n\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        // between changes\n        const n = i - iStart;\n\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2; // subtract excess common lines\n\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] !== _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1; // add patch lines\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1; // add patch line\n  }\n\n  const jLast = jLength - 1;\n  const lines = [];\n  let jPatchMark = 0; // index of placeholder line for current patch mark\n\n  if (hasPatch) {\n    lines.push(''); // placeholder line for first patch mark\n  } // Indexes of expected or received lines in current patch:\n\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n\n  const pushCommonLine = line => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  };\n\n  const pushDeleteLine = line => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  };\n\n  const pushInsertLine = line => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  }; // Second pass: push lines with diff formatting (and patch marks, if needed).\n\n  i = 0;\n\n  while (i !== iLength) {\n    let iStart = i;\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at beginning\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        // at end\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        // between changes\n        const nCommon = i - iStart;\n\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n\n          lines[jPatchMark] = createPatchMark(\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            options\n          );\n          jPatchMark = lines.length;\n          lines.push(''); // placeholder line for next patch mark\n\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n\n    while (i !== iLength && diffs[i][0] === _cleanupSemantic.DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n\n  return lines.join('\\n');\n}; // jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\n\nexports.joinAlignedDiffsNoExpand = joinAlignedDiffsNoExpand;\n\nconst joinAlignedDiffsExpand = (diffs, options) =>\n  diffs\n    .map((diff, i, diffs) => {\n      const line = diff[1];\n      const isFirstOrLast = i === 0 || i === diffs.length - 1;\n\n      switch (diff[0]) {\n        case _cleanupSemantic.DIFF_DELETE:\n          return printDeleteLine(line, isFirstOrLast, options);\n\n        case _cleanupSemantic.DIFF_INSERT:\n          return printInsertLine(line, isFirstOrLast, options);\n\n        default:\n          return printCommonLine(line, isFirstOrLast, options);\n      }\n    })\n    .join('\\n');\n\nexports.joinAlignedDiffsExpand = joinAlignedDiffsExpand;\n"]},"metadata":{},"sourceType":"script"}