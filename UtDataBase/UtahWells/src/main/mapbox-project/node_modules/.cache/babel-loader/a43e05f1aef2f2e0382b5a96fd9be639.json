{"ast":null,"code":"import { LngLat, Point } from 'mapbox-gl';\nexport var anchors = ['center', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];\nexport var anchorTranslates = {\n  center: 'translate(-50%, -50%)',\n  top: 'translate(-50%, 0)',\n  left: 'translate(0, -50%)',\n  right: 'translate(-100%, -50%)',\n  bottom: 'translate(-50%, -100%)',\n  'top-left': 'translate(0, 0)',\n  'top-right': 'translate(-100%, 0)',\n  'bottom-left': 'translate(0, -100%)',\n  'bottom-right': 'translate(-100%, -100%)'\n};\nvar defaultElement = {\n  offsetWidth: 0,\n  offsetHeight: 0\n};\nvar defaultPoint = [0, 0];\n\nvar projectCoordinates = function (map, coordinates) {\n  return map.project(LngLat.convert(coordinates));\n};\n\nvar calculateAnchor = function (map, offsets, position, _a) {\n  var _b = _a === void 0 ? defaultElement : _a,\n      offsetHeight = _b.offsetHeight,\n      offsetWidth = _b.offsetWidth;\n\n  var anchor = [];\n\n  if (position.y + offsets.bottom.y - offsetHeight < 0) {\n    anchor = [anchors[1]];\n  } else if (position.y + offsets.top.y + offsetHeight > map.transform.height) {\n    anchor = [anchors[2]];\n  }\n\n  if (position.x < offsetWidth / 2) {\n    anchor.push(anchors[3]);\n  } else if (position.x > map.transform.width - offsetWidth / 2) {\n    anchor.push(anchors[4]);\n  }\n\n  if (anchor.length === 0) {\n    return anchors[2];\n  }\n\n  return anchor.join('-');\n};\n\nvar normalizedOffsets = function (offset) {\n  if (!offset) {\n    return normalizedOffsets(new Point(0, 0));\n  }\n\n  if (typeof offset === 'number') {\n    var cornerOffset = Math.round(Math.sqrt(0.5 * Math.pow(offset, 2)));\n    return {\n      center: new Point(offset, offset),\n      top: new Point(0, offset),\n      bottom: new Point(0, -offset),\n      left: new Point(offset, 0),\n      right: new Point(-offset, 0),\n      'top-left': new Point(cornerOffset, cornerOffset),\n      'top-right': new Point(-cornerOffset, cornerOffset),\n      'bottom-left': new Point(cornerOffset, -cornerOffset),\n      'bottom-right': new Point(-cornerOffset, -cornerOffset)\n    };\n  }\n\n  if (offset instanceof Point || Array.isArray(offset)) {\n    return anchors.reduce(function (res, anchor) {\n      res[anchor] = Point.convert(offset);\n      return res;\n    }, {});\n  }\n\n  return anchors.reduce(function (res, anchor) {\n    res[anchor] = Point.convert(offset[anchor] || defaultPoint);\n    return res;\n  }, {});\n};\n\nexport var overlayState = function (props, map, container) {\n  var position = projectCoordinates(map, props.coordinates);\n  var offsets = normalizedOffsets(props.offset);\n  var anchor = props.anchor || calculateAnchor(map, offsets, position, container);\n  return {\n    anchor: anchor,\n    position: position,\n    offset: offsets[anchor]\n  };\n};\n\nvar moveTranslate = function (point) {\n  return point ? \"translate(\" + point.x.toFixed(0) + \"px, \" + point.y.toFixed(0) + \"px)\" : '';\n};\n\nexport var overlayTransform = function (_a) {\n  var anchor = _a.anchor,\n      position = _a.position,\n      offset = _a.offset;\n  var res = [];\n\n  if (position) {\n    res.push(moveTranslate(position));\n  }\n\n  if (offset && offset.x !== undefined && offset.y !== undefined) {\n    res.push(moveTranslate(offset));\n  }\n\n  if (anchor) {\n    res.push(anchorTranslates[anchor]);\n  }\n\n  return res;\n};","map":{"version":3,"mappings":"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","names":["LngLat","Point","anchors","anchorTranslates","center","top","left","right","bottom","defaultElement","offsetWidth","offsetHeight","defaultPoint","projectCoordinates","map","coordinates","project","convert","calculateAnchor","offsets","position","_a","_b","anchor","y","transform","height","x","push","width","length","join","normalizedOffsets","offset","cornerOffset","Math","round","sqrt","pow","Array","isArray","reduce","res","overlayState","props","container","moveTranslate","point","toFixed","overlayTransform","undefined"],"sources":["D:\\Github\\CUSP_DataBase\\CUSP_DB\\src\\main\\mapbox-project\\node_modules\\react-mapbox-gl\\src\\util\\overlays.ts"],"sourcesContent":["import { LngLat, Point, Map } from 'mapbox-gl';\nimport { Props } from '../projected-layer';\nimport { Anchor, AnchorsOffset } from './types';\n\nexport interface PointDef {\n  x: number;\n  y: number;\n}\n\nexport interface OverlayParams {\n  anchor?: Anchor;\n  offset?: Point;\n  position?: Point;\n}\n\nexport const anchors = [\n  'center',\n  'top',\n  'bottom',\n  'left',\n  'right',\n  'top-left',\n  'top-right',\n  'bottom-left',\n  'bottom-right'\n] as Anchor[];\n\nexport const anchorTranslates = {\n  center: 'translate(-50%, -50%)',\n  top: 'translate(-50%, 0)',\n  left: 'translate(0, -50%)',\n  right: 'translate(-100%, -50%)',\n  bottom: 'translate(-50%, -100%)',\n  'top-left': 'translate(0, 0)',\n  'top-right': 'translate(-100%, 0)',\n  'bottom-left': 'translate(0, -100%)',\n  'bottom-right': 'translate(-100%, -100%)'\n};\n\n// Hack /o\\\nconst defaultElement = { offsetWidth: 0, offsetHeight: 0 };\nconst defaultPoint = [0, 0];\n\nconst projectCoordinates = (map: Map, coordinates: [number, number]) =>\n  map.project(LngLat.convert(coordinates));\n\nconst calculateAnchor = (\n  map: Map,\n  offsets: AnchorsOffset,\n  position: PointDef,\n  { offsetHeight, offsetWidth } = defaultElement\n) => {\n  let anchor: string[] = [];\n\n  if (position.y + offsets.bottom.y - offsetHeight < 0) {\n    anchor = [anchors[1]];\n  } else if (\n    position.y + offsets.top.y + offsetHeight >\n    // tslint:disable-next-line:no-any\n    (map as any).transform.height\n  ) {\n    anchor = [anchors[2]];\n  }\n\n  if (position.x < offsetWidth / 2) {\n    anchor.push(anchors[3]);\n    // tslint:disable-next-line:no-any\n  } else if (position.x > (map as any).transform.width - offsetWidth / 2) {\n    anchor.push(anchors[4]);\n  }\n\n  if (anchor.length === 0) {\n    return anchors[2];\n  }\n\n  return anchor.join('-') as Anchor;\n};\n\nconst normalizedOffsets = (\n  offset?: number | Point | AnchorsOffset | [number, number]\n): AnchorsOffset => {\n  if (!offset) {\n    return normalizedOffsets(new Point(0, 0));\n  }\n\n  if (typeof offset === 'number') {\n    // input specifies a radius from which to calculate offsets at all positions\n    const cornerOffset = Math.round(Math.sqrt(0.5 * Math.pow(offset, 2)));\n    return {\n      center: new Point(offset, offset),\n      top: new Point(0, offset),\n      bottom: new Point(0, -offset),\n      left: new Point(offset, 0),\n      right: new Point(-offset, 0),\n      'top-left': new Point(cornerOffset, cornerOffset),\n      'top-right': new Point(-cornerOffset, cornerOffset),\n      'bottom-left': new Point(cornerOffset, -cornerOffset),\n      'bottom-right': new Point(-cornerOffset, -cornerOffset)\n    };\n  }\n\n  if (offset instanceof Point || Array.isArray(offset)) {\n    // input specifies a single offset to be applied to all positions\n    return anchors.reduce(\n      (res, anchor) => {\n        res[anchor] = Point.convert(offset);\n        return res;\n      },\n      // tslint:disable-next-line:no-object-literal-type-assertion\n      {} as AnchorsOffset\n    );\n  }\n\n  // input specifies an offset per position\n  return anchors.reduce(\n    (res, anchor) => {\n      res[anchor] = Point.convert(offset[anchor] || defaultPoint);\n      return res;\n    },\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    {} as AnchorsOffset\n  );\n};\n\nexport const overlayState = (\n  props: Props,\n  map: Map,\n  container: HTMLElement\n) => {\n  const position = projectCoordinates(map, props.coordinates);\n  const offsets = normalizedOffsets(props.offset);\n  const anchor =\n    props.anchor || calculateAnchor(map, offsets, position, container);\n\n  return {\n    anchor,\n    position,\n    offset: offsets[anchor]\n  };\n};\n\nconst moveTranslate = (point: Point) =>\n  point ? `translate(${point.x.toFixed(0)}px, ${point.y.toFixed(0)}px)` : '';\n\nexport const overlayTransform = ({\n  anchor,\n  position,\n  offset\n}: OverlayParams) => {\n  const res = [];\n\n  if (position) {\n    res.push(moveTranslate(position));\n  }\n\n  if (offset && offset.x !== undefined && offset.y !== undefined) {\n    res.push(moveTranslate(offset));\n  }\n\n  if (anchor) {\n    res.push(anchorTranslates[anchor]);\n  }\n\n  return res;\n};\n"]},"metadata":{},"sourceType":"module"}